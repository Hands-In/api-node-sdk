/* tslint:disable */
/* eslint-disable */
/**
 * Merchant API
 * The Hands In API is the first and only service that enables users to transact within a group. Our API is heavily orientated around being a RESTful service  that has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, ant utilizes standard HTTP response codes
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ACHDetails
 */
export interface ACHDetails {
    /**
     * The routing number for the bank account.
     * @type {string}
     * @memberof ACHDetails
     */
    'routingNumber'?: string;
    /**
     * The last few digits of the bank account number.
     * @type {string}
     * @memberof ACHDetails
     */
    'accountNumberSuffix'?: string;
    /**
     * The type of the bank account performing the transfer. The account type can be `CHECKING`, `SAVINGS`, or `UNKNOWN`.
     * @type {string}
     * @memberof ACHDetails
     */
    'accountType'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AVSStatus = {
    Accepted: 'AVS_ACCEPTED',
    Rejected: 'AVS_REJECTED',
    NotChecked: 'AVS_NOT_CHECKED'
} as const;

export type AVSStatus = typeof AVSStatus[keyof typeof AVSStatus];


/**
 * 
 * @export
 * @interface AccountApp
 */
export interface AccountApp {
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    'accId': string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    'appName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AccountCreationParams
 */
export interface AccountCreationParams {
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof AccountCreationParams
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof AccountCreationParams
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AccountCreationParams
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountCreationParams
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountCreationParams
     */
    'language'?: string;
    /**
     * 
     * @type {Country}
     * @memberof AccountCreationParams
     */
    'country'?: Country;
}
/**
 * 
 * @export
 * @interface AccountDTO
 */
export interface AccountDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountDTO
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {Country}
     * @memberof AccountDTO
     */
    'country'?: Country;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {AddressLines}
     * @memberof Address
     */
    'addressLines': AddressLines;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * 
     * @type {Country}
     * @memberof Address
     */
    'country'?: Country;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postalCode'?: string;
    /**
     * 
     * @type {Sublocality}
     * @memberof Address
     */
    'sublocality'?: Sublocality;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'organization'?: string;
}
/**
 * 
 * @export
 * @interface AddressLines
 */
export interface AddressLines {
    /**
     * 
     * @type {string}
     * @memberof AddressLines
     */
    'addressLine1': string;
    /**
     * 
     * @type {string}
     * @memberof AddressLines
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressLines
     */
    'addressLine3'?: string;
}
/**
 * 
 * @export
 * @interface AdjustableQuantity
 */
export interface AdjustableQuantity {
    /**
     * 
     * @type {number}
     * @memberof AdjustableQuantity
     */
    'minimum': number;
    /**
     * 
     * @type {number}
     * @memberof AdjustableQuantity
     */
    'maxmimum': number;
}
/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface BankAccountPaymentDetails
 */
export interface BankAccountPaymentDetails {
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    'bankName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    'transferType'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    'accountOwnershipType'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    'statementDescription'?: string;
    /**
     * 
     * @type {ACHDetails}
     * @memberof BankAccountPaymentDetails
     */
    'achDetails'?: ACHDetails;
    /**
     * 
     * @type {Array<PaymentError>}
     * @memberof BankAccountPaymentDetails
     */
    'errors'?: Array<PaymentError>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CVVStatus = {
    Accepted: 'CVV_ACCEPTED',
    Rejected: 'CVV_REJECTED',
    NotChecked: 'CVV_NOT_CHECKED'
} as const;

export type CVVStatus = typeof CVVStatus[keyof typeof CVVStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const CaptureMethod = {
    Payment: 'PAYMENT',
    Capture: 'CAPTURE',
    Subscription: 'SUBSCRIPTION'
} as const;

export type CaptureMethod = typeof CaptureMethod[keyof typeof CaptureMethod];


/**
 * 
 * @export
 * @enum {string}
 */

export const CardBrand = {
    OtherBrand: 'OTHER_BRAND',
    Visa: 'VISA',
    Mastercard: 'MASTERCARD',
    AmericanExpress: 'AMERICAN_EXPRESS',
    Discover: 'DISCOVER',
    DiscoverDiners: 'DISCOVER_DINERS',
    Jcb: 'JCB',
    ChinaUnionpay: 'CHINA_UNIONPAY',
    SquareGiftCard: 'SQUARE_GIFT_CARD',
    SquareCapitalCard: 'SQUARE_CAPITAL_CARD',
    Interac: 'INTERAC',
    Eftpos: 'EFTPOS',
    Felica: 'FELICA',
    Ebt: 'EBT'
} as const;

export type CardBrand = typeof CardBrand[keyof typeof CardBrand];


/**
 * 
 * @export
 * @interface CardDetails
 */
export interface CardDetails {
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'id': string;
    /**
     * 
     * @type {CardBrand}
     * @memberof CardDetails
     */
    'cardBrand': CardBrand;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'last4'?: string;
    /**
     * 
     * @type {number}
     * @memberof CardDetails
     */
    'expMonth'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardDetails
     */
    'expYear'?: number;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'cardholderName'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CardDetails
     */
    'billingAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'referenceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardDetails
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'cardType'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'prepaidType'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'bin'?: string;
}
/**
 * 
 * @export
 * @interface CardPaymentDetails
 */
export interface CardPaymentDetails {
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'status'?: string;
    /**
     * 
     * @type {CardDetails}
     * @memberof CardPaymentDetails
     */
    'card'?: CardDetails;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'entryMethod'?: string;
    /**
     * 
     * @type {CVVStatus}
     * @memberof CardPaymentDetails
     */
    'cvvStatus'?: CVVStatus;
    /**
     * 
     * @type {AVSStatus}
     * @memberof CardPaymentDetails
     */
    'avsStatus'?: AVSStatus;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'authResultCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'applicationIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'applicationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'applicationCryptogram'?: string;
    /**
     * 
     * @type {CardVerificationMethod}
     * @memberof CardPaymentDetails
     */
    'verificationMethod'?: CardVerificationMethod;
    /**
     * 
     * @type {CardVerificationResult}
     * @memberof CardPaymentDetails
     */
    'verificationResults'?: CardVerificationResult;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'statementDescription'?: string;
    /**
     * 
     * @type {DeviceDetails}
     * @memberof CardPaymentDetails
     */
    'deviceDetails'?: DeviceDetails;
    /**
     * 
     * @type {CardPaymentTimeline}
     * @memberof CardPaymentDetails
     */
    'cardPaymentTimeline'?: CardPaymentTimeline;
    /**
     * 
     * @type {boolean}
     * @memberof CardPaymentDetails
     */
    'refundRequiresCardPresence'?: boolean;
    /**
     * Information about errors encountered during the request.
     * @type {Array<PaymentError>}
     * @memberof CardPaymentDetails
     */
    'errors'?: Array<PaymentError>;
}
/**
 * 
 * @export
 * @interface CardPaymentTimeline
 */
export interface CardPaymentTimeline {
    /**
     * 
     * @type {string}
     * @memberof CardPaymentTimeline
     */
    'authorizedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentTimeline
     */
    'capturedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentTimeline
     */
    'voidedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CardVerificationMethod = {
    Pin: 'PIN',
    PinAndSignature: 'PIN_AND_SIGNATURE',
    Signature: 'SIGNATURE',
    OnDevice: 'ON_DEVICE',
    None: 'NONE'
} as const;

export type CardVerificationMethod = typeof CardVerificationMethod[keyof typeof CardVerificationMethod];


/**
 * 
 * @export
 * @enum {string}
 */

export const CardVerificationResult = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Unknown: 'UNKNOWN'
} as const;

export type CardVerificationResult = typeof CardVerificationResult[keyof typeof CardVerificationResult];


/**
 * 
 * @export
 * @interface CashPaymentDetails
 */
export interface CashPaymentDetails {
    /**
     * 
     * @type {Money}
     * @memberof CashPaymentDetails
     */
    'buyerSuppliedMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof CashPaymentDetails
     */
    'changeBackMoney'?: Money;
}
/**
 * 
 * @export
 * @interface CheckoutLineItemCreationParam
 */
export interface CheckoutLineItemCreationParam {
    /**
     * Item can be created inline if neccessary
     * @type {string | ItemCreationParams}
     * @memberof CheckoutLineItemCreationParam
     */
    'item': string | ItemCreationParams;
    /**
     * 
     * @type {number}
     * @memberof CheckoutLineItemCreationParam
     */
    'quantity': number;
    /**
     * 
     * @type {AdjustableQuantity}
     * @memberof CheckoutLineItemCreationParam
     */
    'adjustableQuantity'?: AdjustableQuantity;
}
/**
 * 
 * @export
 * @interface CheckoutPageOptions
 */
export interface CheckoutPageOptions {
    /**
     * 
     * @type {CaptureMethod}
     * @memberof CheckoutPageOptions
     */
    'captureMethod': CaptureMethod;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof CheckoutPageOptions
     */
    'successUrl'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof CheckoutPageOptions
     */
    'cancelUrl'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof CheckoutPageOptions
     */
    'expireUrl'?: string;
    /**
     * 
     * @type {object}
     * @memberof CheckoutPageOptions
     */
    'enableGroupPayments'?: object;
    /**
     * 
     * @type {object}
     * @memberof CheckoutPageOptions
     */
    'enableTips'?: object;
    /**
     * 
     * @type {object}
     * @memberof CheckoutPageOptions
     */
    'enableDiscounts'?: object;
    /**
     * Will pre-apply an array of discount codes Discounts have to be enabled first.
     * @type {Array<string>}
     * @memberof CheckoutPageOptions
     */
    'discountCodes'?: Array<string>;
    /**
     * 
     * @type {Array<PaymentMethod>}
     * @memberof CheckoutPageOptions
     */
    'paymentMethods'?: Array<PaymentMethod>;
    /**
     * 
     * @type {CheckoutStyle}
     * @memberof CheckoutPageOptions
     */
    'style'?: CheckoutStyle;
    /**
     * 
     * @type {object}
     * @memberof CheckoutPageOptions
     */
    'showEditItemsPage'?: object;
}
/**
 * 
 * @export
 * @interface CheckoutSession
 */
export interface CheckoutSession {
    /**
     * 
     * @type {string}
     * @memberof CheckoutSession
     */
    'id': string;
    /**
     * 
     * @type {CheckoutStatus}
     * @memberof CheckoutSession
     */
    'status': CheckoutStatus;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSession
     */
    'expirationDate': string;
    /**
     * User will populate data in checkout session if provided
     * @type {string}
     * @memberof CheckoutSession
     */
    'customerId'?: string;
    /**
     * The order associated with the checkout session
     * @type {string}
     * @memberof CheckoutSession
     */
    'orderId': string;
    /**
     * The payment associated with the checkout session Could be either single payment or group payment
     * @type {string}
     * @memberof CheckoutSession
     */
    'paymentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSession
     */
    'groupPaymentId'?: string;
    /**
     * 
     * @type {CheckoutPageOptions}
     * @memberof CheckoutSession
     */
    'checkoutOptions': CheckoutPageOptions;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof CheckoutSession
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSession
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSession
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CheckoutSession
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSession
     */
    'referenceId'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CheckoutSession
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CheckoutSessionCreationParams
 */
export interface CheckoutSessionCreationParams {
    /**
     * 
     * @type {Array<CheckoutLineItemCreationParam>}
     * @memberof CheckoutSessionCreationParams
     */
    'lineItemParams': Array<CheckoutLineItemCreationParam>;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionCreationParams
     */
    'referenceId'?: string;
    /**
     * 
     * @type {CustomerCreationParams | string}
     * @memberof CheckoutSessionCreationParams
     */
    'customer'?: CustomerCreationParams | string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionCreationParams
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {CheckoutPageOptions}
     * @memberof CheckoutSessionCreationParams
     */
    'checkoutPageOptions': CheckoutPageOptions;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CheckoutSessionCreationParams
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CheckoutStatus = {
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED',
    Pending: 'PENDING'
} as const;

export type CheckoutStatus = typeof CheckoutStatus[keyof typeof CheckoutStatus];


/**
 * 
 * @export
 * @interface CheckoutStyle
 */
export interface CheckoutStyle {
    /**
     * 
     * @type {string}
     * @memberof CheckoutStyle
     */
    'secondaryColor': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutStyle
     */
    'primaryColor': string;
}
/**
 * 
 * @export
 * @interface ClientCreationParams
 */
export interface ClientCreationParams {
    /**
     * 
     * @type {string}
     * @memberof ClientCreationParams
     */
    'name': string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof ClientCreationParams
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientCreationParams
     */
    'redirectUris'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientCreationParams
     */
    'scopes': Array<string>;
}
/**
 * Client response will automatically give bool values determining if client is verified or not
 * @export
 * @interface ClientResponse
 */
export interface ClientResponse {
    /**
     * 
     * @type {string}
     * @memberof ClientResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClientResponse
     */
    'name': string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof ClientResponse
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientResponse
     */
    'redirectUris'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClientResponse
     */
    'secretKey': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientResponse
     */
    'scopes': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClientResponse
     */
    'ownerId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClientResponse
     */
    'verified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientResponse
     */
    'trusted': boolean;
}
/**
 * 
 * @export
 * @interface ClientResponseAllOf
 */
export interface ClientResponseAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof ClientResponseAllOf
     */
    'verified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientResponseAllOf
     */
    'trusted': boolean;
}
/**
 * 
 * @export
 * @interface ConnectRecord
 */
export interface ConnectRecord {
    /**
     * 
     * @type {string}
     * @memberof ConnectRecord
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRecord
     */
    'service': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRecord
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRecord
     */
    'refreshToken': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRecord
     */
    'expiresAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Country = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kr: 'KR',
    Kp: 'KP',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    False: 'false',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type Country = typeof Country[keyof typeof Country];


/**
 * 
 * @export
 * @interface CreateGroupPaymentRequest
 */
export interface CreateGroupPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'idempotencyKey': string;
    /**
     * Can either be a customerId or customer object
     * @type {string | CustomerCreationParams}
     * @memberof CreateGroupPaymentRequest
     */
    'customer': string | CustomerCreationParams;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'checkoutId'?: string;
    /**
     * 
     * @type {SplitType}
     * @memberof CreateGroupPaymentRequest
     */
    'splitType'?: SplitType;
    /**
     * 
     * @type {number}
     * @memberof CreateGroupPaymentRequest
     */
    'splitAllocation'?: number;
    /**
     * 
     * @type {{ [key: string]: Money; }}
     * @memberof CreateGroupPaymentRequest
     */
    'customAllocation'?: { [key: string]: Money; };
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof CreateGroupPaymentRequest
     */
    'itemAllocation'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {Money}
     * @memberof CreateGroupPaymentRequest
     */
    'amountMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof CreateGroupPaymentRequest
     */
    'tipMoney'?: Money;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CreateGroupPaymentRequest
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'referenceId'?: string;
}
/**
 * 
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'paymentToken': string;
    /**
     * 
     * @type {Money}
     * @memberof CreatePaymentRequest
     */
    'amountMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof CreatePaymentRequest
     */
    'tipMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof CreatePaymentRequest
     */
    'sellerFee'?: Money;
    /**
     * 
     * @type {Address}
     * @memberof CreatePaymentRequest
     */
    'billingAddress'?: Address;
    /**
     * 
     * @type {Address}
     * @memberof CreatePaymentRequest
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePaymentRequest
     */
    'autocomplete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'verificationToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'referenceId'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Currency = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mru: 'MRU',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Stn: 'STN',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Ves: 'VES',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwl: 'ZWL'
} as const;

export type Currency = typeof Currency[keyof typeof Currency];


/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'lastName'?: string;
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof Customer
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'phoneNumber'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof Customer
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Customer
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface CustomerCreationParams
 */
export interface CustomerCreationParams {
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    'lastName'?: string;
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof CustomerCreationParams
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    'language'?: string;
}
/**
 * 
 * @export
 * @interface DeviceDetails
 */
export interface DeviceDetails {
    /**
     * 
     * @type {string}
     * @memberof DeviceDetails
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDetails
     */
    'deviceInstallationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDetails
     */
    'deviceName'?: string;
}
/**
 * 
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    'code': string;
    /**
     * 
     * @type {Money}
     * @memberof Discount
     */
    'amountMoney': Money;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DisplayType = {
    Page: 'page',
    Popup: 'popup',
    Touch: 'touch',
    Wap: 'wap'
} as const;

export type DisplayType = typeof DisplayType[keyof typeof DisplayType];


/**
 * 
 * @export
 * @interface Dispute
 */
export interface Dispute {
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'paymentId': string;
    /**
     * 
     * @type {Money}
     * @memberof Dispute
     */
    'amountMoney': Money;
    /**
     * 
     * @type {DisputeReason}
     * @memberof Dispute
     */
    'reason': DisputeReason;
    /**
     * 
     * @type {DisputeStatus}
     * @memberof Dispute
     */
    'status': DisputeStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof Dispute
     */
    'evidenceIds'?: Array<string>;
    /**
     * 
     * @type {CardBrand}
     * @memberof Dispute
     */
    'cardBrand'?: CardBrand;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'brandDisputeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'dueAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'reportedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'locationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DisputeReason = {
    AmountDiffers: 'AMOUNT_DIFFERS',
    Cancelled: 'CANCELLED',
    Duplicate: 'DUPLICATE',
    NoKnowledge: 'NO_KNOWLEDGE',
    NotAsDescribed: 'NOT_AS_DESCRIBED',
    NotReceived: 'NOT_RECEIVED',
    PaidByOtherMeans: 'PAID_BY_OTHER_MEANS',
    CustomerRequestsCredit: 'CUSTOMER_REQUESTS_CREDIT',
    EmvLiabilityShift: 'EMV_LIABILITY_SHIFT'
} as const;

export type DisputeReason = typeof DisputeReason[keyof typeof DisputeReason];


/**
 * 
 * @export
 * @enum {string}
 */

export const DisputeStatus = {
    Unknown: 'UNKNOWN',
    InquiryEvidenceRequired: 'INQUIRY_EVIDENCE_REQUIRED',
    InquiryProcessing: 'INQUIRY_PROCESSING',
    InquiryClosed: 'INQUIRY_CLOSED',
    EvidenceRequired: 'EVIDENCE_REQUIRED',
    Processing: 'PROCESSING',
    Won: 'WON',
    Lost: 'LOST',
    Accepted: 'ACCEPTED',
    WaitingThirdParty: 'WAITING_THIRD_PARTY'
} as const;

export type DisputeStatus = typeof DisputeStatus[keyof typeof DisputeStatus];


/**
 * 
 * @export
 * @interface ETSITokenResponse
 */
export interface ETSITokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ETSITokenResponse
     */
    'nfv_token'?: string;
}
/**
 * 
 * @export
 * @interface Email
 */
export interface Email {
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Email
     */
    'to': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Email
     */
    'cc'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Email
     */
    'bcc'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'html'?: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'text'?: string;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof Email
     */
    'attachment'?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'referenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'templateName'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Email
     */
    'variables'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Email
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface EmailCreationParams
 */
export interface EmailCreationParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCreationParams
     */
    'to': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EmailCreationParams
     */
    'subject': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCreationParams
     */
    'cc'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCreationParams
     */
    'bcc'?: Array<string>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof EmailCreationParams
     */
    'attachment'?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof EmailCreationParams
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof EmailCreationParams
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof EmailCreationParams
     */
    'templateName': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EmailCreationParams
     */
    'variables'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ExternalPaymentDetails
 */
export interface ExternalPaymentDetails {
    /**
     * 
     * @type {string}
     * @memberof ExternalPaymentDetails
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalPaymentDetails
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalPaymentDetails
     */
    'sourceId'?: string;
    /**
     * 
     * @type {Money}
     * @memberof ExternalPaymentDetails
     */
    'sourceFeeMoney'?: Money;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'ownerId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Group
     */
    'memberIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface GroupCreationParams
 */
export interface GroupCreationParams {
    /**
     * 
     * @type {string}
     * @memberof GroupCreationParams
     */
    'ownerId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupCreationParams
     */
    'memberIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GroupCreationParams
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GroupPaymentRecord
 */
export interface GroupPaymentRecord {
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'ownerId': string;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof GroupPaymentRecord
     */
    'status': PaymentStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupPaymentRecord
     */
    'memberIds': Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GroupPaymentRecord
     */
    'memberPayments': { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof GroupPaymentRecord
     */
    'splitAllocation'?: number;
    /**
     * 
     * @type {SplitType}
     * @memberof GroupPaymentRecord
     */
    'splitType': SplitType;
    /**
     * 
     * @type {{ [key: string]: Money; }}
     * @memberof GroupPaymentRecord
     */
    'customAllocation'?: { [key: string]: Money; };
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof GroupPaymentRecord
     */
    'itemAllocation'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'orderId'?: string;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'totalMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'amountMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'tipMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'approvedMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'refundedMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'groupAppFee'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'totalAppFees'?: Money;
    /**
     * 
     * @type {Array<ProcessingFee>}
     * @memberof GroupPaymentRecord
     */
    'processingFees'?: Array<ProcessingFee>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupPaymentRecord
     */
    'refundIds'?: Array<string>;
    /**
     * 
     * @type {Address}
     * @memberof GroupPaymentRecord
     */
    'shippingAddress'?: Address;
    /**
     * If the total payment is not made up by the group members by this date then the transaction will be cancelled. Default 7 days.
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof GroupPaymentRecord
     */
    'riskEvaluation'?: RiskEvaluation;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'referenceId'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GroupPaymentRecord
     */
    'metaData'?: { [key: string]: string; };
    /**
     * The inviteUrl is only generated when the group payment is fully hosted by hands in
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'url'?: string;
    /**
     * The message is shown to everyone in the group when fully hosted by hands in
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof GroupPaymentRecord
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface GroupPaymentRefundRequest
 */
export interface GroupPaymentRefundRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRefundRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRefundRequest
     */
    'appFee'?: Money;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRefundRequest
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface GroupPaymentUpdateParams
 */
export interface GroupPaymentUpdateParams {
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentUpdateParams
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentUpdateParams
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentUpdateParams
     */
    'checkoutId'?: string;
    /**
     * 
     * @type {SplitType}
     * @memberof GroupPaymentUpdateParams
     */
    'splitType'?: SplitType;
    /**
     * 
     * @type {number}
     * @memberof GroupPaymentUpdateParams
     */
    'splitAllocation'?: number;
    /**
     * 
     * @type {{ [key: string]: Money; }}
     * @memberof GroupPaymentUpdateParams
     */
    'customAllocation'?: { [key: string]: Money; };
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof GroupPaymentUpdateParams
     */
    'itemAllocation'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentUpdateParams
     */
    'amountMoney'?: Money;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentUpdateParams
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {Address}
     * @memberof GroupPaymentUpdateParams
     */
    'shippingAddress'?: Address;
    /**
     * If this is set to true, the group payment will be completed as soon as the total amount is made up  Defaults to true.
     * @type {boolean}
     * @memberof GroupPaymentUpdateParams
     */
    'autocomplete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentUpdateParams
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentUpdateParams
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentUpdateParams
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentUpdateParams
     */
    'referenceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupPaymentUpdateParams
     */
    'emailNotification'?: boolean;
}
/**
 * 
 * @export
 * @interface GroupPaymentUpdateParamsAllOf
 */
export interface GroupPaymentUpdateParamsAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof GroupPaymentUpdateParamsAllOf
     */
    'emailNotification'?: boolean;
}
/**
 * 
 * @export
 * @interface HtmlEmailCreationParams
 */
export interface HtmlEmailCreationParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof HtmlEmailCreationParams
     */
    'to': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof HtmlEmailCreationParams
     */
    'subject': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HtmlEmailCreationParams
     */
    'cc'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof HtmlEmailCreationParams
     */
    'bcc'?: Array<string>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof HtmlEmailCreationParams
     */
    'attachment'?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof HtmlEmailCreationParams
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof HtmlEmailCreationParams
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof HtmlEmailCreationParams
     */
    'templateName'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof HtmlEmailCreationParams
     */
    'variables'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface IESGTokenResponse
 */
export interface IESGTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof IESGTokenResponse
     */
    'issued_token_type'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IETFResponseType = {
    Code: 'code',
    Token: 'token'
} as const;

export type IETFResponseType = typeof IETFResponseType[keyof typeof IETFResponseType];


/**
 * 
 * @export
 * @interface IETFTokenResponse
 */
export interface IETFTokenResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof IETFTokenResponse
     */
    'scope'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'token_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof IETFTokenResponse
     */
    'expires_in'?: number;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'ace_profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'rs_cnf'?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'cnf'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject1
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject1
     */
    'resend'?: boolean;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'sku'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'name': string;
    /**
     * 
     * @type {Money}
     * @memberof Item
     */
    'amountMoney': Money;
    /**
     * Key-value pairs that help to differentiate variants
     * @type {{ [key: string]: string; }}
     * @memberof Item
     */
    'attributes'?: { [key: string]: string; };
    /**
     * 
     * @type {ItemOrderDetails}
     * @memberof Item
     */
    'orderDetails'?: ItemOrderDetails;
    /**
     * 
     * @type {ItemInventoryDetails}
     * @memberof Item
     */
    'inventoryDetails'?: ItemInventoryDetails;
    /**
     * Max 10 images per item. Default image is the first in array.
     * @type {Array<string>}
     * @memberof Item
     */
    'imageUrls'?: Array<string>;
    /**
     * 300 word description of the item.
     * @type {string}
     * @memberof Item
     */
    'description'?: string;
    /**
     * referenceId for merchant to use for internal system
     * @type {string}
     * @memberof Item
     */
    'referenceId'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Item
     */
    'metaData'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface ItemCreationParams
 */
export interface ItemCreationParams {
    /**
     * 
     * @type {string}
     * @memberof ItemCreationParams
     */
    'sku'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCreationParams
     */
    'name': string;
    /**
     * 
     * @type {Money}
     * @memberof ItemCreationParams
     */
    'amountMoney': Money;
    /**
     * Key-value pairs that help to differentiate variants
     * @type {{ [key: string]: string; }}
     * @memberof ItemCreationParams
     */
    'attributes'?: { [key: string]: string; };
    /**
     * Max of 10 images per item. The first will always be the default.
     * @type {Array<string>}
     * @memberof ItemCreationParams
     */
    'imageUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ItemCreationParams
     */
    'description'?: string;
    /**
     * 
     * @type {ItemCreationParamsOrderDetails}
     * @memberof ItemCreationParams
     */
    'orderDetails'?: ItemCreationParamsOrderDetails;
    /**
     * 
     * @type {ItemCreationParamsInventoryDetails}
     * @memberof ItemCreationParams
     */
    'inventoryDetails'?: ItemCreationParamsInventoryDetails;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ItemCreationParams
     */
    'metaData'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ItemCreationParams
     */
    'referenceId'?: string;
}
/**
 * 
 * @export
 * @interface ItemCreationParamsInventoryDetails
 */
export interface ItemCreationParamsInventoryDetails {
    /**
     * 
     * @type {number}
     * @memberof ItemCreationParamsInventoryDetails
     */
    'unitsAvailable'?: number;
    /**
     * This will be shown on your Hands In catalogue
     * @type {string}
     * @memberof ItemCreationParamsInventoryDetails
     */
    'unitType'?: string;
}
/**
 * 
 * @export
 * @interface ItemCreationParamsOrderDetails
 */
export interface ItemCreationParamsOrderDetails {
    /**
     * This will default to the units available if not provided
     * @type {number}
     * @memberof ItemCreationParamsOrderDetails
     */
    'maxUnitsPerOrder'?: number;
    /**
     * This will default to 0 if not provided
     * @type {number}
     * @memberof ItemCreationParamsOrderDetails
     */
    'minUnitsPerOrder'?: number;
    /**
     * Set to true if the item can be shipped
     * @type {boolean}
     * @memberof ItemCreationParamsOrderDetails
     */
    'isShippable'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemInventoryDetails
 */
export interface ItemInventoryDetails {
    /**
     * 
     * @type {number}
     * @memberof ItemInventoryDetails
     */
    'unitsAvailable'?: number;
    /**
     * This will be shown on your Hands In and checkout pages
     * @type {string}
     * @memberof ItemInventoryDetails
     */
    'unitType'?: string;
}
/**
 * 
 * @export
 * @interface ItemListParams
 */
export interface ItemListParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemListParams
     */
    'itemIds': Array<string>;
}
/**
 * Details used by the ordering service to determine limitations for orders
 * @export
 * @interface ItemOrderDetails
 */
export interface ItemOrderDetails {
    /**
     * Set to true if item is must be shipped out
     * @type {boolean}
     * @memberof ItemOrderDetails
     */
    'isShippable'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemUpdateParams
 */
export interface ItemUpdateParams {
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateParams
     */
    'sku'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateParams
     */
    'name': string;
    /**
     * 
     * @type {Money}
     * @memberof ItemUpdateParams
     */
    'amountMoney': Money;
    /**
     * Key-value pairs that help to differentiate variants
     * @type {{ [key: string]: string; }}
     * @memberof ItemUpdateParams
     */
    'attributes'?: { [key: string]: string; };
    /**
     * Max of 10 images per item. The first will always be the default.
     * @type {Array<string>}
     * @memberof ItemUpdateParams
     */
    'imageUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateParams
     */
    'description'?: string;
    /**
     * 
     * @type {ItemCreationParamsOrderDetails}
     * @memberof ItemUpdateParams
     */
    'orderDetails'?: ItemCreationParamsOrderDetails;
    /**
     * 
     * @type {ItemCreationParamsInventoryDetails}
     * @memberof ItemUpdateParams
     */
    'inventoryDetails'?: ItemCreationParamsInventoryDetails;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ItemUpdateParams
     */
    'metaData'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateParams
     */
    'referenceId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemUpdateParams
     */
    'atomicUnitChange'?: number;
}
/**
 * 
 * @export
 * @interface JoinGroupPaymentRequest
 */
export interface JoinGroupPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof JoinGroupPaymentRequest
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface KickGroupPaymentRequest
 */
export interface KickGroupPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof KickGroupPaymentRequest
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof KickGroupPaymentRequest
     */
    'kickId': string;
}
/**
 * 
 * @export
 * @interface LeaveGroupPaymentRequest
 */
export interface LeaveGroupPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof LeaveGroupPaymentRequest
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof LeaveGroupPaymentRequest
     */
    'newOwnerId'?: string;
}
/**
 * 
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * 
     * @type {PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails}
     * @memberof LineItem
     */
    'item': PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    'quantity': number;
    /**
     * 
     * @type {Money}
     * @memberof LineItem
     */
    'taxAmount'?: Money;
    /**
     * 
     * @type {Array<Tax>}
     * @memberof LineItem
     */
    'taxes'?: Array<Tax>;
    /**
     * 
     * @type {Money}
     * @memberof LineItem
     */
    'subtotalAmount': Money;
    /**
     * 
     * @type {Money}
     * @memberof LineItem
     */
    'totalAmount': Money;
}
/**
 * 
 * @export
 * @interface LineItemCreationParam
 */
export interface LineItemCreationParam {
    /**
     * Item can be created inline if neccessary
     * @type {string | ItemCreationParams}
     * @memberof LineItemCreationParam
     */
    'item': string | ItemCreationParams;
    /**
     * 
     * @type {number}
     * @memberof LineItemCreationParam
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface LoginParams
 */
export interface LoginParams {
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof LoginParams
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof LoginParams
     */
    'password': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoginParams
     */
    'scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MerchantApiKeySummary
 */
export interface MerchantApiKeySummary {
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    'merchantToken': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface MerchantContactDetails
 */
export interface MerchantContactDetails {
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof MerchantContactDetails
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantContactDetails
     */
    'companyNumber'?: string;
    /**
     * 
     * @type {Address}
     * @memberof MerchantContactDetails
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof MerchantContactDetails
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface MerchantDTO
 */
export interface MerchantDTO {
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {MerchantContactDetails}
     * @memberof MerchantDTO
     */
    'contactDetails': MerchantContactDetails;
    /**
     * 
     * @type {Array<MerchantApiKeySummary>}
     * @memberof MerchantDTO
     */
    'liveKeys': Array<MerchantApiKeySummary>;
    /**
     * 
     * @type {Array<MerchantApiKeySummary>}
     * @memberof MerchantDTO
     */
    'testKeys': Array<MerchantApiKeySummary>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof MerchantDTO
     */
    'team': { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof MerchantDTO
     */
    'invites'?: { [key: string]: object; };
    /**
     * 
     * @type {Currency}
     * @memberof MerchantDTO
     */
    'defaultCurrency': Currency;
}
/**
 * 
 * @export
 * @interface Money
 */
export interface Money {
    /**
     * 
     * @type {number}
     * @memberof Money
     */
    'amount': number;
    /**
     * 
     * @type {Currency}
     * @memberof Money
     */
    'currency': Currency;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthGrantType = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;

export type OAuthGrantType = typeof OAuthGrantType[keyof typeof OAuthGrantType];


/**
 * 
 * @export
 * @interface OAuthResponseType
 */
export interface OAuthResponseType {
}
/**
 * 
 * @export
 * @interface OAuthTokenResponse
 */
export interface OAuthTokenResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof OAuthTokenResponse
     */
    'scope'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'token_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof OAuthTokenResponse
     */
    'expires_in'?: number;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'ace_profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'rs_cnf'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'cnf'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'id_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'session_state'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'issued_token_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'nfv_token'?: string;
}
/**
 * 
 * @export
 * @interface OpenIDTokenResponse
 */
export interface OpenIDTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof OpenIDTokenResponse
     */
    'id_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIDTokenResponse
     */
    'session_state'?: string;
}
/**
 * 
 * @export
 * @interface OpenIdAddress
 */
export interface OpenIdAddress {
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    'postal_code': string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    'locality': string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    'street_address': string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    'formatted': string;
}
/**
 * 
 * @export
 * @interface OpenIdIdTokenData
 */
export interface OpenIdIdTokenData {
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'sub': string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'given_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'family_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'middle_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'preferred_username'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'picture'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'profile'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'gender'?: OpenIdIdTokenDataGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'birthdate'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'zoneinfo'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'locale'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'phone_number'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenIdIdTokenData
     */
    'phone_number_verified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenIdIdTokenData
     */
    'email_verified'?: boolean;
    /**
     * 
     * @type {OpenIdAddress}
     * @memberof OpenIdIdTokenData
     */
    'address'?: OpenIdAddress;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'auth_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'nonce'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'acr'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'amr'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    'azp'?: string;
}

export const OpenIdIdTokenDataGenderEnum = {
    Female: 'female',
    Male: 'male'
} as const;

export type OpenIdIdTokenDataGenderEnum = typeof OpenIdIdTokenDataGenderEnum[keyof typeof OpenIdIdTokenDataGenderEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const OpenIdResponseType = {
    IdToken: 'id_token',
    IdTokenToken: 'id_token token',
    CodeIdTokenToken: 'code id_token token',
    CodeIdToken: 'code id_token',
    CodeToken: 'code token',
    None: 'none'
} as const;

export type OpenIdResponseType = typeof OpenIdResponseType[keyof typeof OpenIdResponseType];


/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof Order
     */
    'status': OrderStatus;
    /**
     * 
     * @type {Array<LineItem>}
     * @memberof Order
     */
    'lineItems': Array<LineItem>;
    /**
     * 
     * @type {Money}
     * @memberof Order
     */
    'totalMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof Order
     */
    'subtotalMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof Order
     */
    'discountMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Order
     */
    'tipMoney'?: Money;
    /**
     * 
     * @type {Array<Tax>}
     * @memberof Order
     */
    'taxes'?: Array<Tax>;
    /**
     * 
     * @type {Array<Discount>}
     * @memberof Order
     */
    'discounts'?: Array<Discount>;
    /**
     * 
     * @type {Address}
     * @memberof Order
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Order
     */
    'metaData'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface OrderCreationParams
 */
export interface OrderCreationParams {
    /**
     * 
     * @type {Array<LineItemCreationParam>}
     * @memberof OrderCreationParams
     */
    'lineItemParams': Array<LineItemCreationParam>;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrderCreationParams
     */
    'discountCodes'?: Array<string>;
    /**
     * Customer who is paying for the order
     * @type {string | CustomerCreationParams}
     * @memberof OrderCreationParams
     */
    'customer'?: string | CustomerCreationParams;
    /**
     * 
     * @type {Address}
     * @memberof OrderCreationParams
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof OrderCreationParams
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderStatus = {
    Pending: 'PENDING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Fulfilled: 'FULFILLED',
    Returned: 'RETURNED'
} as const;

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


/**
 * Make all properties in T optional
 * @export
 * @interface PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
 */
export interface PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey {
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'checkoutId'?: string;
    /**
     * 
     * @type {SplitType}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'splitType'?: SplitType;
    /**
     * 
     * @type {number}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'splitAllocation'?: number;
    /**
     * 
     * @type {{ [key: string]: Money; }}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'customAllocation'?: { [key: string]: Money; };
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'itemAllocation'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {Money}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'amountMoney'?: Money;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {Address}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'shippingAddress'?: Address;
    /**
     * If this is set to true, the group payment will be completed as soon as the total amount is made up  Defaults to true.
     * @type {boolean}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'autocomplete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey
     */
    'referenceId'?: string;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialOrderCreationParams
 */
export interface PartialOrderCreationParams {
    /**
     * 
     * @type {Array<LineItemCreationParam>}
     * @memberof PartialOrderCreationParams
     */
    'lineItemParams'?: Array<LineItemCreationParam>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PartialOrderCreationParams
     */
    'discountCodes'?: Array<string>;
    /**
     * Customer who is paying for the order
     * @type {string | CustomerCreationParams}
     * @memberof PartialOrderCreationParams
     */
    'customer'?: string | CustomerCreationParams;
    /**
     * 
     * @type {Address}
     * @memberof PartialOrderCreationParams
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PartialOrderCreationParams
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface PasswordResetParams
 */
export interface PasswordResetParams {
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof PasswordResetParams
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof PasswordResetParams
     */
    'password': string;
    /**
     * Password
     * @type {string}
     * @memberof PasswordResetParams
     */
    'confirmPassword': string;
}
/**
 * 
 * @export
 * @interface PayIntoGroupPaymentRequest
 */
export interface PayIntoGroupPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'paymentToken': string;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'customerId': string;
    /**
     * 
     * @type {Money}
     * @memberof PayIntoGroupPaymentRequest
     */
    'tipMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof PayIntoGroupPaymentRequest
     */
    'appFee'?: Money;
    /**
     * 
     * @type {Address}
     * @memberof PayIntoGroupPaymentRequest
     */
    'billingAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'verificationToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'referenceId'?: string;
}
/**
 * 
 * @export
 * @interface PaymentError
 */
export interface PaymentError {
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    'field'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentMethod = {
    Card: 'CARD',
    BankAccount: 'BANK_ACCOUNT',
    Cash: 'CASH',
    External: 'EXTERNAL'
} as const;

export type PaymentMethod = typeof PaymentMethod[keyof typeof PaymentMethod];


/**
 * 
 * @export
 * @interface PaymentRecord
 */
export interface PaymentRecord {
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'groupPaymentId'?: string;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    'totalMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    'amountMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    'tipMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    'approvedMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    'refundedMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    'appFee'?: Money;
    /**
     * 
     * @type {Array<ProcessingFee>}
     * @memberof PaymentRecord
     */
    'processingFees'?: Array<ProcessingFee>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentRecord
     */
    'refundIds'?: Array<string>;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof PaymentRecord
     */
    'status': PaymentStatus;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentRecord
     */
    'paymentMethod': PaymentMethod;
    /**
     * 
     * @type {CardPaymentDetails}
     * @memberof PaymentRecord
     */
    'cardDetails'?: CardPaymentDetails;
    /**
     * 
     * @type {BankAccountPaymentDetails}
     * @memberof PaymentRecord
     */
    'bankAccountDetails'?: BankAccountPaymentDetails;
    /**
     * 
     * @type {CashPaymentDetails}
     * @memberof PaymentRecord
     */
    'cashDetails'?: CashPaymentDetails;
    /**
     * 
     * @type {ExternalPaymentDetails}
     * @memberof PaymentRecord
     */
    'externalDetails'?: ExternalPaymentDetails;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'locationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'referenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'employeeId'?: string;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof PaymentRecord
     */
    'riskEvaluation'?: RiskEvaluation;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'buyerEmailAddress'?: string;
    /**
     * 
     * @type {Address}
     * @memberof PaymentRecord
     */
    'billingAddress'?: Address;
    /**
     * 
     * @type {Address}
     * @memberof PaymentRecord
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentRecord
     */
    'capabilities'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'receiptNumber'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof PaymentRecord
     */
    'receiptUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'versionToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof PaymentRecord
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface PaymentRefundRequest
 */
export interface PaymentRefundRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentRefundRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRefundRequest
     */
    'amountMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRefundRequest
     */
    'appFee'?: Money;
    /**
     * 
     * @type {string}
     * @memberof PaymentRefundRequest
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
    Approved: 'APPROVED',
    Pending: 'PENDING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickClientExcludeKeyofClientVerifiedSigOrTrustedSig
 */
export interface PickClientExcludeKeyofClientVerifiedSigOrTrustedSig {
    /**
     * 
     * @type {string}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig
     */
    'name': string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig
     */
    'redirectUris'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig
     */
    'secretKey': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig
     */
    'scopes': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig
     */
    'ownerId'?: string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails
 */
export interface PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails {
    /**
     * 
     * @type {string}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails
     */
    'name': string;
    /**
     * 
     * @type {Money}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails
     */
    'amountMoney': Money;
    /**
     * Key-value pairs that help to differentiate variants
     * @type {{ [key: string]: string; }}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails
     */
    'attributes'?: { [key: string]: string; };
    /**
     * 300 word description of the item.
     * @type {string}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails
     */
    'metaData'?: { [key: string]: string; };
    /**
     * Max 10 images per item. Default image is the first in array.
     * @type {Array<string>}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails
     */
    'imageUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails
     */
    'sku'?: string;
    /**
     * 
     * @type {ItemOrderDetails}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails
     */
    'orderDetails'?: ItemOrderDetails;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency
 */
export interface PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency {
    /**
     * 
     * @type {string}
     * @memberof PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency
     */
    'name': string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {MerchantContactDetails}
     * @memberof PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency
     */
    'contactDetails': MerchantContactDetails;
    /**
     * 
     * @type {Currency}
     * @memberof PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency
     */
    'defaultCurrency': Currency;
}
/**
 * 
 * @export
 * @interface ProcessingFee
 */
export interface ProcessingFee {
    /**
     * 
     * @type {string}
     * @memberof ProcessingFee
     */
    'effectiveAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessingFee
     */
    'type'?: string;
    /**
     * 
     * @type {Money}
     * @memberof ProcessingFee
     */
    'amountMoney': Money;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PromptType = {
    Consent: 'consent',
    SelectAccount: 'select_account',
    Login: 'login',
    None: 'none'
} as const;

export type PromptType = typeof PromptType[keyof typeof PromptType];


/**
 * 
 * @export
 * @interface RefundRecord
 */
export interface RefundRecord {
    /**
     * 
     * @type {string}
     * @memberof RefundRecord
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RefundRecord
     */
    'paymentId': string;
    /**
     * 
     * @type {Money}
     * @memberof RefundRecord
     */
    'amountMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof RefundRecord
     */
    'appFee'?: Money;
    /**
     * 
     * @type {RefundStatus}
     * @memberof RefundRecord
     */
    'status': RefundStatus;
    /**
     * 
     * @type {Array<ProcessingFee>}
     * @memberof RefundRecord
     */
    'processingFees'?: Array<ProcessingFee>;
    /**
     * 
     * @type {string}
     * @memberof RefundRecord
     */
    'locationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundRecord
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundRecord
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RefundStatus = {
    Pending: 'PENDING',
    Completed: 'COMPLETED',
    Rejected: 'REJECTED',
    Failed: 'FAILED'
} as const;

export type RefundStatus = typeof RefundStatus[keyof typeof RefundStatus];


/**
 * 
 * @export
 * @interface RequestResetParams
 */
export interface RequestResetParams {
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof RequestResetParams
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RequestResetParams
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestResetParams
     */
    'browser'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestResetParams
     */
    'device'?: string;
}
/**
 * 
 * @export
 * @interface RiskEvaluation
 */
export interface RiskEvaluation {
    /**
     * 
     * @type {string}
     * @memberof RiskEvaluation
     */
    'createdAt'?: string;
    /**
     * 
     * @type {RiskLevel}
     * @memberof RiskEvaluation
     */
    'riskLevel': RiskLevel;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RiskLevel = {
    Low: 'LOW',
    Moderate: 'MODERATE',
    High: 'HIGH'
} as const;

export type RiskLevel = typeof RiskLevel[keyof typeof RiskLevel];


/**
 * 
 * @export
 * @enum {string}
 */

export const Service = {
    Square: 'square',
    Stripe: 'stripe'
} as const;

export type Service = typeof Service[keyof typeof Service];


/**
 * 
 * @export
 * @enum {string}
 */

export const SplitType = {
    Equal: 'EQUAL',
    ByItem: 'BY_ITEM',
    Custom: 'CUSTOM'
} as const;

export type SplitType = typeof SplitType[keyof typeof SplitType];


/**
 * 
 * @export
 * @interface Sublocality
 */
export interface Sublocality {
    /**
     * 
     * @type {string}
     * @memberof Sublocality
     */
    'sublocality1': string;
    /**
     * 
     * @type {string}
     * @memberof Sublocality
     */
    'sublocality2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sublocality
     */
    'sublocality3'?: string;
}
/**
 * 
 * @export
 * @interface Tax
 */
export interface Tax {
    /**
     * 
     * @type {string}
     * @memberof Tax
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Tax
     */
    'code': string;
    /**
     * 
     * @type {Money}
     * @memberof Tax
     */
    'amountMoney': Money;
}
/**
 * 
 * @export
 * @interface TemplateEmailCreationParams
 */
export interface TemplateEmailCreationParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof TemplateEmailCreationParams
     */
    'to': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TemplateEmailCreationParams
     */
    'subject': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TemplateEmailCreationParams
     */
    'cc'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TemplateEmailCreationParams
     */
    'bcc'?: Array<string>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof TemplateEmailCreationParams
     */
    'attachment'?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof TemplateEmailCreationParams
     */
    'html'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateEmailCreationParams
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateEmailCreationParams
     */
    'templateName': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TemplateEmailCreationParams
     */
    'variables'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface TextEmailCreationParams
 */
export interface TextEmailCreationParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof TextEmailCreationParams
     */
    'to': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TextEmailCreationParams
     */
    'subject': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TextEmailCreationParams
     */
    'cc'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TextEmailCreationParams
     */
    'bcc'?: Array<string>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof TextEmailCreationParams
     */
    'attachment'?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof TextEmailCreationParams
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof TextEmailCreationParams
     */
    'html'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextEmailCreationParams
     */
    'templateName'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TextEmailCreationParams
     */
    'variables'?: { [key: string]: string; };
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Supply an account JWT access token and delete the associated profile from it
         * @summary Delete an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Hands In account by supplying the necessary details
         * @summary Create an account
         * @param {AccountCreationParams} accountCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (accountCreationParams: AccountCreationParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountCreationParams' is not null or undefined
            assertParamExists('create', 'accountCreationParams', accountCreationParams)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountCreationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply an account JWT access token and receive all profile data stored by Hands In
         * @summary Retrieve account profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply an account JWT access token and retrieve the all the applications that are connected to this account
         * @summary List connected account applications
         * @param {string} [appName] 
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (appName?: string, pageNum?: number, pageSize?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (appName !== undefined) {
                localVarQueryParameter['appName'] = appName;
            }

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Supply an account JWT access token and delete the associated profile from it
         * @summary Delete an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Hands In account by supplying the necessary details
         * @summary Create an account
         * @param {AccountCreationParams} accountCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(accountCreationParams: AccountCreationParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(accountCreationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply an account JWT access token and receive all profile data stored by Hands In
         * @summary Retrieve account profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply an account JWT access token and retrieve the all the applications that are connected to this account
         * @summary List connected account applications
         * @param {string} [appName] 
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(appName?: string, pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountApp>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(appName, pageNum, pageSize, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Supply an account JWT access token and delete the associated profile from it
         * @summary Delete an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(options?: any): AxiosPromise<void> {
            return localVarFp._delete(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Hands In account by supplying the necessary details
         * @summary Create an account
         * @param {AccountCreationParams} accountCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(accountCreationParams: AccountCreationParams, options?: any): AxiosPromise<AccountDTO> {
            return localVarFp.create(accountCreationParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply an account JWT access token and receive all profile data stored by Hands In
         * @summary Retrieve account profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: any): AxiosPromise<AccountDTO> {
            return localVarFp.getProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Supply an account JWT access token and retrieve the all the applications that are connected to this account
         * @summary List connected account applications
         * @param {string} [appName] 
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(appName?: string, pageNum?: number, pageSize?: number, limit?: number, options?: any): AxiosPromise<Array<AccountApp>> {
            return localVarFp.listApplications(appName, pageNum, pageSize, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Supply an account JWT access token and delete the associated profile from it
     * @summary Delete an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public _delete(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration)._delete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Hands In account by supplying the necessary details
     * @summary Create an account
     * @param {AccountCreationParams} accountCreationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public create(accountCreationParams: AccountCreationParams, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).create(accountCreationParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply an account JWT access token and receive all profile data stored by Hands In
     * @summary Retrieve account profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getProfile(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply an account JWT access token and retrieve the all the applications that are connected to this account
     * @summary List connected account applications
     * @param {string} [appName] 
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listApplications(appName?: string, pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listApplications(appName, pageNum, pageSize, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Supply an email and password to recieve a JWT token which gives acts as an identification token for all resources hosted by Hands In
         * @summary Login to your Hands In account
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginParams: LoginParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginParams' is not null or undefined
            assertParamExists('login', 'loginParams', loginParams)
            const localVarPath = `/authentication/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requesting a password reset will email a link to the account enabling them to reset their password
         * @summary Create a reset password request
         * @param {RequestResetParams} requestResetParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset: async (requestResetParams: RequestResetParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestResetParams' is not null or undefined
            assertParamExists('requestPasswordReset', 'requestResetParams', requestResetParams)
            const localVarPath = `/authentication/request-reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestResetParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset account password
         * @summary Reset password
         * @param {string} resetToken 
         * @param {PasswordResetParams} passwordResetParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetToken: string, passwordResetParams: PasswordResetParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetToken' is not null or undefined
            assertParamExists('resetPassword', 'resetToken', resetToken)
            // verify required parameter 'passwordResetParams' is not null or undefined
            assertParamExists('resetPassword', 'passwordResetParams', passwordResetParams)
            const localVarPath = `/authentication/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (resetToken !== undefined) {
                localVarQueryParameter['resetToken'] = resetToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Supply an email and password to recieve a JWT token which gives acts as an identification token for all resources hosted by Hands In
         * @summary Login to your Hands In account
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginParams: LoginParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requesting a password reset will email a link to the account enabling them to reset their password
         * @summary Create a reset password request
         * @param {RequestResetParams} requestResetParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestPasswordReset(requestResetParams: RequestResetParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestPasswordReset(requestResetParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset account password
         * @summary Reset password
         * @param {string} resetToken 
         * @param {PasswordResetParams} passwordResetParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetToken: string, passwordResetParams: PasswordResetParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetToken, passwordResetParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Supply an email and password to recieve a JWT token which gives acts as an identification token for all resources hosted by Hands In
         * @summary Login to your Hands In account
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginParams: LoginParams, options?: any): AxiosPromise<OAuthTokenResponse> {
            return localVarFp.login(loginParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Requesting a password reset will email a link to the account enabling them to reset their password
         * @summary Create a reset password request
         * @param {RequestResetParams} requestResetParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset(requestResetParams: RequestResetParams, options?: any): AxiosPromise<OAuthTokenResponse> {
            return localVarFp.requestPasswordReset(requestResetParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset account password
         * @summary Reset password
         * @param {string} resetToken 
         * @param {PasswordResetParams} passwordResetParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetToken: string, passwordResetParams: PasswordResetParams, options?: any): AxiosPromise<void> {
            return localVarFp.resetPassword(resetToken, passwordResetParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Supply an email and password to recieve a JWT token which gives acts as an identification token for all resources hosted by Hands In
     * @summary Login to your Hands In account
     * @param {LoginParams} loginParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(loginParams: LoginParams, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(loginParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requesting a password reset will email a link to the account enabling them to reset their password
     * @summary Create a reset password request
     * @param {RequestResetParams} requestResetParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public requestPasswordReset(requestResetParams: RequestResetParams, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).requestPasswordReset(requestResetParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset account password
     * @summary Reset password
     * @param {string} resetToken 
     * @param {PasswordResetParams} passwordResetParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public resetPassword(resetToken: string, passwordResetParams: PasswordResetParams, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).resetPassword(resetToken, passwordResetParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CheckoutsApi - axios parameter creator
 * @export
 */
export const CheckoutsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
         * @summary Create a checkout session
         * @param {CheckoutSessionCreationParams} checkoutSessionCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout: async (checkoutSessionCreationParams: CheckoutSessionCreationParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutSessionCreationParams' is not null or undefined
            assertParamExists('createCheckout', 'checkoutSessionCreationParams', checkoutSessionCreationParams)
            const localVarPath = `/checkouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutSessionCreationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique dispute ID and receive corresponding checkout details.
         * @summary Retrieve a checkout session
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckout: async (checkoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutId' is not null or undefined
            assertParamExists('getCheckout', 'checkoutId', checkoutId)
            const localVarPath = `/checkouts/{checkoutId}`
                .replace(`{${"checkoutId"}}`, encodeURIComponent(String(checkoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of checkout sessions by supplying the correct parameters.
         * @summary List all checkout sessions
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCheckouts: async (pageNum?: number, pageSize?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/checkouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a checkout session by supplying the correct parameters.
         * @summary Update a checkout session
         * @param {string} checkoutId 
         * @param {CheckoutSessionCreationParams} checkoutSessionCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckout: async (checkoutId: string, checkoutSessionCreationParams: CheckoutSessionCreationParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutId' is not null or undefined
            assertParamExists('updateCheckout', 'checkoutId', checkoutId)
            // verify required parameter 'checkoutSessionCreationParams' is not null or undefined
            assertParamExists('updateCheckout', 'checkoutSessionCreationParams', checkoutSessionCreationParams)
            const localVarPath = `/checkouts/{checkoutId}`
                .replace(`{${"checkoutId"}}`, encodeURIComponent(String(checkoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutSessionCreationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutsApi - functional programming interface
 * @export
 */
export const CheckoutsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckoutsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
         * @summary Create a checkout session
         * @param {CheckoutSessionCreationParams} checkoutSessionCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckout(checkoutSessionCreationParams: CheckoutSessionCreationParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckout(checkoutSessionCreationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply the unique dispute ID and receive corresponding checkout details.
         * @summary Retrieve a checkout session
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckout(checkoutId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckout(checkoutId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of checkout sessions by supplying the correct parameters.
         * @summary List all checkout sessions
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCheckouts(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CheckoutSession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCheckouts(pageNum, pageSize, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a checkout session by supplying the correct parameters.
         * @summary Update a checkout session
         * @param {string} checkoutId 
         * @param {CheckoutSessionCreationParams} checkoutSessionCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCheckout(checkoutId: string, checkoutSessionCreationParams: CheckoutSessionCreationParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCheckout(checkoutId, checkoutSessionCreationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CheckoutsApi - factory interface
 * @export
 */
export const CheckoutsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckoutsApiFp(configuration)
    return {
        /**
         * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
         * @summary Create a checkout session
         * @param {CheckoutSessionCreationParams} checkoutSessionCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout(checkoutSessionCreationParams: CheckoutSessionCreationParams, options?: any): AxiosPromise<CheckoutSession> {
            return localVarFp.createCheckout(checkoutSessionCreationParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply the unique dispute ID and receive corresponding checkout details.
         * @summary Retrieve a checkout session
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckout(checkoutId: string, options?: any): AxiosPromise<CheckoutSession> {
            return localVarFp.getCheckout(checkoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of checkout sessions by supplying the correct parameters.
         * @summary List all checkout sessions
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCheckouts(pageNum?: number, pageSize?: number, limit?: number, options?: any): AxiosPromise<Array<CheckoutSession>> {
            return localVarFp.listCheckouts(pageNum, pageSize, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a checkout session by supplying the correct parameters.
         * @summary Update a checkout session
         * @param {string} checkoutId 
         * @param {CheckoutSessionCreationParams} checkoutSessionCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckout(checkoutId: string, checkoutSessionCreationParams: CheckoutSessionCreationParams, options?: any): AxiosPromise<CheckoutSession> {
            return localVarFp.updateCheckout(checkoutId, checkoutSessionCreationParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckoutsApi - object-oriented interface
 * @export
 * @class CheckoutsApi
 * @extends {BaseAPI}
 */
export class CheckoutsApi extends BaseAPI {
    /**
     * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
     * @summary Create a checkout session
     * @param {CheckoutSessionCreationParams} checkoutSessionCreationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public createCheckout(checkoutSessionCreationParams: CheckoutSessionCreationParams, options?: AxiosRequestConfig) {
        return CheckoutsApiFp(this.configuration).createCheckout(checkoutSessionCreationParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply the unique dispute ID and receive corresponding checkout details.
     * @summary Retrieve a checkout session
     * @param {string} checkoutId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public getCheckout(checkoutId: string, options?: AxiosRequestConfig) {
        return CheckoutsApiFp(this.configuration).getCheckout(checkoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of checkout sessions by supplying the correct parameters.
     * @summary List all checkout sessions
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public listCheckouts(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig) {
        return CheckoutsApiFp(this.configuration).listCheckouts(pageNum, pageSize, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a checkout session by supplying the correct parameters.
     * @summary Update a checkout session
     * @param {string} checkoutId 
     * @param {CheckoutSessionCreationParams} checkoutSessionCreationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public updateCheckout(checkoutId: string, checkoutSessionCreationParams: CheckoutSessionCreationParams, options?: AxiosRequestConfig) {
        return CheckoutsApiFp(this.configuration).updateCheckout(checkoutId, checkoutSessionCreationParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Customer
         * @param {CustomerCreationParams} customerCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (customerCreationParams: CustomerCreationParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerCreationParams' is not null or undefined
            assertParamExists('createCustomer', 'customerCreationParams', customerCreationParams)
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerCreationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique customer ID and recieve the corresponding customer.
         * @summary Retrieve a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Customer
         * @param {CustomerCreationParams} customerCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(customerCreationParams: CustomerCreationParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(customerCreationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply the unique customer ID and recieve the corresponding customer.
         * @summary Retrieve a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Customer
         * @param {CustomerCreationParams} customerCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(customerCreationParams: CustomerCreationParams, options?: any): AxiosPromise<Customer> {
            return localVarFp.createCustomer(customerCreationParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.deleteCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply the unique customer ID and recieve the corresponding customer.
         * @summary Retrieve a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.getCustomer(customerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * 
     * @summary Create a Customer
     * @param {CustomerCreationParams} customerCreationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomer(customerCreationParams: CustomerCreationParams, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).createCustomer(customerCreationParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).deleteCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply the unique customer ID and recieve the corresponding customer.
     * @summary Retrieve a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmailsApi - axios parameter creator
 * @export
 */
export const EmailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve email details given the email ID
         * @summary Retrieve an email
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: async (emailId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailId' is not null or undefined
            assertParamExists('getEmail', 'emailId', emailId)
            const localVarPath = `/emails/{emailId}`
                .replace(`{${"emailId"}}`, encodeURIComponent(String(emailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of emails given the required parameters
         * @summary List emails
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails: async (pageNum?: number, pageSize?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from handsin by providing the parameters
         * @summary Send an email
         * @param {EmailCreationParams} emailCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: async (emailCreationParams: EmailCreationParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailCreationParams' is not null or undefined
            assertParamExists('sendEmail', 'emailCreationParams', emailCreationParams)
            const localVarPath = `/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailCreationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailsApi - functional programming interface
 * @export
 */
export const EmailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmailsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve email details given the email ID
         * @summary Retrieve an email
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmail(emailId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Email>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmail(emailId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of emails given the required parameters
         * @summary List emails
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEmails(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Email>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEmails(pageNum, pageSize, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send an email from handsin by providing the parameters
         * @summary Send an email
         * @param {EmailCreationParams} emailCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmail(emailCreationParams: EmailCreationParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Email>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmail(emailCreationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmailsApi - factory interface
 * @export
 */
export const EmailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailsApiFp(configuration)
    return {
        /**
         * Retrieve email details given the email ID
         * @summary Retrieve an email
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(emailId: string, options?: any): AxiosPromise<Email> {
            return localVarFp.getEmail(emailId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of emails given the required parameters
         * @summary List emails
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails(pageNum?: number, pageSize?: number, limit?: number, options?: any): AxiosPromise<Array<Email>> {
            return localVarFp.listEmails(pageNum, pageSize, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Send an email from handsin by providing the parameters
         * @summary Send an email
         * @param {EmailCreationParams} emailCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(emailCreationParams: EmailCreationParams, options?: any): AxiosPromise<Email> {
            return localVarFp.sendEmail(emailCreationParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmailsApi - object-oriented interface
 * @export
 * @class EmailsApi
 * @extends {BaseAPI}
 */
export class EmailsApi extends BaseAPI {
    /**
     * Retrieve email details given the email ID
     * @summary Retrieve an email
     * @param {string} emailId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailsApi
     */
    public getEmail(emailId: string, options?: AxiosRequestConfig) {
        return EmailsApiFp(this.configuration).getEmail(emailId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of emails given the required parameters
     * @summary List emails
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailsApi
     */
    public listEmails(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig) {
        return EmailsApiFp(this.configuration).listEmails(pageNum, pageSize, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send an email from handsin by providing the parameters
     * @summary Send an email
     * @param {EmailCreationParams} emailCreationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailsApi
     */
    public sendEmail(emailCreationParams: EmailCreationParams, options?: AxiosRequestConfig) {
        return EmailsApiFp(this.configuration).sendEmail(emailCreationParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupPaymentsApi - axios parameter creator
 * @export
 */
export const GroupPaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a group payment
         * @param {string} groupPaymentId 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupPayment: async (groupPaymentId: string, inlineObject: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('cancelGroupPayment', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('cancelGroupPayment', 'inlineObject', inlineObject)
            const localVarPath = `/group-payments/{groupPaymentId}/cancel`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a group payment
         * @param {CreateGroupPaymentRequest} createGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPayment: async (createGroupPaymentRequest: CreateGroupPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupPaymentRequest' is not null or undefined
            assertParamExists('createGroupPayment', 'createGroupPaymentRequest', createGroupPaymentRequest)
            const localVarPath = `/group-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique group payment ID and recieve the corresponding group payment.
         * @summary Retrieve a group payment
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPayment: async (groupPaymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('getGroupPayment', 'groupPaymentId', groupPaymentId)
            const localVarPath = `/group-payments/{groupPaymentId}`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all group payment refunds
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPaymentRefunds: async (groupPaymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('getGroupPaymentRefunds', 'groupPaymentId', groupPaymentId)
            const localVarPath = `/group-payments/{groupPaymentId}/refunds`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a group payment
         * @param {string} groupPaymentId 
         * @param {JoinGroupPaymentRequest} joinGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroupPayment: async (groupPaymentId: string, joinGroupPaymentRequest: JoinGroupPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('joinGroupPayment', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'joinGroupPaymentRequest' is not null or undefined
            assertParamExists('joinGroupPayment', 'joinGroupPaymentRequest', joinGroupPaymentRequest)
            const localVarPath = `/group-payments/{groupPaymentId}/join`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(joinGroupPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kick member from a group payment
         * @param {string} groupPaymentId 
         * @param {KickGroupPaymentRequest} kickGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickGroupPayment: async (groupPaymentId: string, kickGroupPaymentRequest: KickGroupPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('kickGroupPayment', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'kickGroupPaymentRequest' is not null or undefined
            assertParamExists('kickGroupPayment', 'kickGroupPaymentRequest', kickGroupPaymentRequest)
            const localVarPath = `/group-payments/{groupPaymentId}/kick`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kickGroupPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave a group payment
         * @param {string} groupPaymentId 
         * @param {LeaveGroupPaymentRequest} leaveGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroupPayment: async (groupPaymentId: string, leaveGroupPaymentRequest: LeaveGroupPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('leaveGroupPayment', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'leaveGroupPaymentRequest' is not null or undefined
            assertParamExists('leaveGroupPayment', 'leaveGroupPaymentRequest', leaveGroupPaymentRequest)
            const localVarPath = `/group-payments/{groupPaymentId}/leave`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leaveGroupPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all group payments
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupPayments: async (pageNum?: number, pageSize?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Collect a payment from an individual user that is intended to be part of a group payment.
         * @summary Pay into a group payment
         * @param {string} groupPaymentId 
         * @param {PayIntoGroupPaymentRequest} payIntoGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInto: async (groupPaymentId: string, payIntoGroupPaymentRequest: PayIntoGroupPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('payInto', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'payIntoGroupPaymentRequest' is not null or undefined
            assertParamExists('payInto', 'payIntoGroupPaymentRequest', payIntoGroupPaymentRequest)
            const localVarPath = `/group-payments/{groupPaymentId}/pay`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payIntoGroupPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a full refund back to each customer that paid into the supplied group payment.
         * @summary Refund a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentRefundRequest} groupPaymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundGroupPayment: async (groupPaymentId: string, groupPaymentRefundRequest: GroupPaymentRefundRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('refundGroupPayment', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'groupPaymentRefundRequest' is not null or undefined
            assertParamExists('refundGroupPayment', 'groupPaymentRefundRequest', groupPaymentRefundRequest)
            const localVarPath = `/group-payments/{groupPaymentId}/refunds`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupPaymentRefundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentUpdateParams} groupPaymentUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPayment: async (groupPaymentId: string, groupPaymentUpdateParams: GroupPaymentUpdateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('updateGroupPayment', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'groupPaymentUpdateParams' is not null or undefined
            assertParamExists('updateGroupPayment', 'groupPaymentUpdateParams', groupPaymentUpdateParams)
            const localVarPath = `/group-payments/{groupPaymentId}`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupPaymentUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupPaymentsApi - functional programming interface
 * @export
 */
export const GroupPaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupPaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel a group payment
         * @param {string} groupPaymentId 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelGroupPayment(groupPaymentId: string, inlineObject: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelGroupPayment(groupPaymentId, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a group payment
         * @param {CreateGroupPaymentRequest} createGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupPayment(createGroupPaymentRequest: CreateGroupPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupPayment(createGroupPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply the unique group payment ID and recieve the corresponding group payment.
         * @summary Retrieve a group payment
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupPayment(groupPaymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupPayment(groupPaymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all group payment refunds
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupPaymentRefunds(groupPaymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupPaymentRefunds(groupPaymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Join a group payment
         * @param {string} groupPaymentId 
         * @param {JoinGroupPaymentRequest} joinGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinGroupPayment(groupPaymentId: string, joinGroupPaymentRequest: JoinGroupPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinGroupPayment(groupPaymentId, joinGroupPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Kick member from a group payment
         * @param {string} groupPaymentId 
         * @param {KickGroupPaymentRequest} kickGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kickGroupPayment(groupPaymentId: string, kickGroupPaymentRequest: KickGroupPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kickGroupPayment(groupPaymentId, kickGroupPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Leave a group payment
         * @param {string} groupPaymentId 
         * @param {LeaveGroupPaymentRequest} leaveGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveGroupPayment(groupPaymentId: string, leaveGroupPaymentRequest: LeaveGroupPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveGroupPayment(groupPaymentId, leaveGroupPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all group payments
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroupPayments(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupPaymentRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroupPayments(pageNum, pageSize, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Collect a payment from an individual user that is intended to be part of a group payment.
         * @summary Pay into a group payment
         * @param {string} groupPaymentId 
         * @param {PayIntoGroupPaymentRequest} payIntoGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payInto(groupPaymentId: string, payIntoGroupPaymentRequest: PayIntoGroupPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payInto(groupPaymentId, payIntoGroupPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a full refund back to each customer that paid into the supplied group payment.
         * @summary Refund a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentRefundRequest} groupPaymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundGroupPayment(groupPaymentId: string, groupPaymentRefundRequest: GroupPaymentRefundRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundGroupPayment(groupPaymentId, groupPaymentRefundRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentUpdateParams} groupPaymentUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupPayment(groupPaymentId: string, groupPaymentUpdateParams: GroupPaymentUpdateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupPayment(groupPaymentId, groupPaymentUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupPaymentsApi - factory interface
 * @export
 */
export const GroupPaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupPaymentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel a group payment
         * @param {string} groupPaymentId 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupPayment(groupPaymentId: string, inlineObject: InlineObject, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.cancelGroupPayment(groupPaymentId, inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a group payment
         * @param {CreateGroupPaymentRequest} createGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPayment(createGroupPaymentRequest: CreateGroupPaymentRequest, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.createGroupPayment(createGroupPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply the unique group payment ID and recieve the corresponding group payment.
         * @summary Retrieve a group payment
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPayment(groupPaymentId: string, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.getGroupPayment(groupPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all group payment refunds
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPaymentRefunds(groupPaymentId: string, options?: any): AxiosPromise<Array<RefundRecord>> {
            return localVarFp.getGroupPaymentRefunds(groupPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a group payment
         * @param {string} groupPaymentId 
         * @param {JoinGroupPaymentRequest} joinGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroupPayment(groupPaymentId: string, joinGroupPaymentRequest: JoinGroupPaymentRequest, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.joinGroupPayment(groupPaymentId, joinGroupPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Kick member from a group payment
         * @param {string} groupPaymentId 
         * @param {KickGroupPaymentRequest} kickGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickGroupPayment(groupPaymentId: string, kickGroupPaymentRequest: KickGroupPaymentRequest, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.kickGroupPayment(groupPaymentId, kickGroupPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave a group payment
         * @param {string} groupPaymentId 
         * @param {LeaveGroupPaymentRequest} leaveGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroupPayment(groupPaymentId: string, leaveGroupPaymentRequest: LeaveGroupPaymentRequest, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.leaveGroupPayment(groupPaymentId, leaveGroupPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all group payments
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupPayments(pageNum?: number, pageSize?: number, limit?: number, options?: any): AxiosPromise<Array<GroupPaymentRecord>> {
            return localVarFp.listGroupPayments(pageNum, pageSize, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Collect a payment from an individual user that is intended to be part of a group payment.
         * @summary Pay into a group payment
         * @param {string} groupPaymentId 
         * @param {PayIntoGroupPaymentRequest} payIntoGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInto(groupPaymentId: string, payIntoGroupPaymentRequest: PayIntoGroupPaymentRequest, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.payInto(groupPaymentId, payIntoGroupPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a full refund back to each customer that paid into the supplied group payment.
         * @summary Refund a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentRefundRequest} groupPaymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundGroupPayment(groupPaymentId: string, groupPaymentRefundRequest: GroupPaymentRefundRequest, options?: any): AxiosPromise<Array<RefundRecord>> {
            return localVarFp.refundGroupPayment(groupPaymentId, groupPaymentRefundRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentUpdateParams} groupPaymentUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPayment(groupPaymentId: string, groupPaymentUpdateParams: GroupPaymentUpdateParams, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.updateGroupPayment(groupPaymentId, groupPaymentUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupPaymentsApi - object-oriented interface
 * @export
 * @class GroupPaymentsApi
 * @extends {BaseAPI}
 */
export class GroupPaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Cancel a group payment
     * @param {string} groupPaymentId 
     * @param {InlineObject} inlineObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public cancelGroupPayment(groupPaymentId: string, inlineObject: InlineObject, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).cancelGroupPayment(groupPaymentId, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a group payment
     * @param {CreateGroupPaymentRequest} createGroupPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public createGroupPayment(createGroupPaymentRequest: CreateGroupPaymentRequest, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).createGroupPayment(createGroupPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply the unique group payment ID and recieve the corresponding group payment.
     * @summary Retrieve a group payment
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public getGroupPayment(groupPaymentId: string, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).getGroupPayment(groupPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all group payment refunds
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public getGroupPaymentRefunds(groupPaymentId: string, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).getGroupPaymentRefunds(groupPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a group payment
     * @param {string} groupPaymentId 
     * @param {JoinGroupPaymentRequest} joinGroupPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public joinGroupPayment(groupPaymentId: string, joinGroupPaymentRequest: JoinGroupPaymentRequest, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).joinGroupPayment(groupPaymentId, joinGroupPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Kick member from a group payment
     * @param {string} groupPaymentId 
     * @param {KickGroupPaymentRequest} kickGroupPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public kickGroupPayment(groupPaymentId: string, kickGroupPaymentRequest: KickGroupPaymentRequest, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).kickGroupPayment(groupPaymentId, kickGroupPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave a group payment
     * @param {string} groupPaymentId 
     * @param {LeaveGroupPaymentRequest} leaveGroupPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public leaveGroupPayment(groupPaymentId: string, leaveGroupPaymentRequest: LeaveGroupPaymentRequest, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).leaveGroupPayment(groupPaymentId, leaveGroupPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all group payments
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public listGroupPayments(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).listGroupPayments(pageNum, pageSize, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Collect a payment from an individual user that is intended to be part of a group payment.
     * @summary Pay into a group payment
     * @param {string} groupPaymentId 
     * @param {PayIntoGroupPaymentRequest} payIntoGroupPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public payInto(groupPaymentId: string, payIntoGroupPaymentRequest: PayIntoGroupPaymentRequest, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).payInto(groupPaymentId, payIntoGroupPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a full refund back to each customer that paid into the supplied group payment.
     * @summary Refund a group payment
     * @param {string} groupPaymentId 
     * @param {GroupPaymentRefundRequest} groupPaymentRefundRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public refundGroupPayment(groupPaymentId: string, groupPaymentRefundRequest: GroupPaymentRefundRequest, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).refundGroupPayment(groupPaymentId, groupPaymentRefundRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a group payment
     * @param {string} groupPaymentId 
     * @param {GroupPaymentUpdateParams} groupPaymentUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public updateGroupPayment(groupPaymentId: string, groupPaymentUpdateParams: GroupPaymentUpdateParams, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).updateGroupPayment(groupPaymentId, groupPaymentUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an item by supplying the correct parameters.
         * @summary Create an item
         * @param {ItemCreationParams} itemCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem: async (itemCreationParams: ItemCreationParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemCreationParams' is not null or undefined
            assertParamExists('createItem', 'itemCreationParams', itemCreationParams)
            const localVarPath = `/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemCreationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a item session by supplying the correct parameters.
         * @summary Delete an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (itemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteItem', 'itemId', itemId)
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique dispute ID and receive corresponding item details.
         * @summary Retrieve an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (itemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getItem', 'itemId', itemId)
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all items by supplying a list of their Ids. Please note, that if any Id\'s are not valid, then they will just be ignored (no error is thrown)
         * @summary Retrieve multiple items
         * @param {ItemListParams} itemListParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: async (itemListParams: ItemListParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemListParams' is not null or undefined
            assertParamExists('getItems', 'itemListParams', itemListParams)
            const localVarPath = `/items/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemListParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of items by supplying the correct parameters.
         * @summary List all items
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems: async (pageNum?: number, pageSize?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a item by supplying the correct parameters.
         * @summary Update an item
         * @param {string} itemId 
         * @param {ItemUpdateParams} itemUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (itemId: string, itemUpdateParams: ItemUpdateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updateItem', 'itemId', itemId)
            // verify required parameter 'itemUpdateParams' is not null or undefined
            assertParamExists('updateItem', 'itemUpdateParams', itemUpdateParams)
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an item by supplying the correct parameters.
         * @summary Create an item
         * @param {ItemCreationParams} itemCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItem(itemCreationParams: ItemCreationParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItem(itemCreationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a item session by supplying the correct parameters.
         * @summary Delete an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(itemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply the unique dispute ID and receive corresponding item details.
         * @summary Retrieve an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(itemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItem(itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all items by supplying a list of their Ids. Please note, that if any Id\'s are not valid, then they will just be ignored (no error is thrown)
         * @summary Retrieve multiple items
         * @param {ItemListParams} itemListParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems(itemListParams: ItemListParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItems(itemListParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of items by supplying the correct parameters.
         * @summary List all items
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItems(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItems(pageNum, pageSize, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a item by supplying the correct parameters.
         * @summary Update an item
         * @param {string} itemId 
         * @param {ItemUpdateParams} itemUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(itemId: string, itemUpdateParams: ItemUpdateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItem(itemId, itemUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * Create an item by supplying the correct parameters.
         * @summary Create an item
         * @param {ItemCreationParams} itemCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(itemCreationParams: ItemCreationParams, options?: any): AxiosPromise<Item> {
            return localVarFp.createItem(itemCreationParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a item session by supplying the correct parameters.
         * @summary Delete an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(itemId: string, options?: any): AxiosPromise<Item> {
            return localVarFp.deleteItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply the unique dispute ID and receive corresponding item details.
         * @summary Retrieve an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, options?: any): AxiosPromise<Item> {
            return localVarFp.getItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all items by supplying a list of their Ids. Please note, that if any Id\'s are not valid, then they will just be ignored (no error is thrown)
         * @summary Retrieve multiple items
         * @param {ItemListParams} itemListParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(itemListParams: ItemListParams, options?: any): AxiosPromise<Array<Item>> {
            return localVarFp.getItems(itemListParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of items by supplying the correct parameters.
         * @summary List all items
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(pageNum?: number, pageSize?: number, limit?: number, options?: any): AxiosPromise<Array<Item>> {
            return localVarFp.listItems(pageNum, pageSize, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a item by supplying the correct parameters.
         * @summary Update an item
         * @param {string} itemId 
         * @param {ItemUpdateParams} itemUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(itemId: string, itemUpdateParams: ItemUpdateParams, options?: any): AxiosPromise<Item> {
            return localVarFp.updateItem(itemId, itemUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * Create an item by supplying the correct parameters.
     * @summary Create an item
     * @param {ItemCreationParams} itemCreationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItem(itemCreationParams: ItemCreationParams, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItem(itemCreationParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a item session by supplying the correct parameters.
     * @summary Delete an item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteItem(itemId: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply the unique dispute ID and receive corresponding item details.
     * @summary Retrieve an item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItem(itemId: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all items by supplying a list of their Ids. Please note, that if any Id\'s are not valid, then they will just be ignored (no error is thrown)
     * @summary Retrieve multiple items
     * @param {ItemListParams} itemListParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItems(itemListParams: ItemListParams, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItems(itemListParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of items by supplying the correct parameters.
     * @summary List all items
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public listItems(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).listItems(pageNum, pageSize, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a item by supplying the correct parameters.
     * @summary Update an item
     * @param {string} itemId 
     * @param {ItemUpdateParams} itemUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateItem(itemId: string, itemUpdateParams: ItemUpdateParams, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateItem(itemId, itemUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MerchantApi - axios parameter creator
 * @export
 */
export const MerchantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provide a ID token to create a merchant. Receive a JWT access token that gives all scope to account.
         * @summary Create a merchant account
         * @param {PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchant: async (body: PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createMerchant', 'body', body)
            const localVarPath = `/merchants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a merchant account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchant: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merchants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply a merchant JWT token and retrieve merchant data
         * @summary Retrieve merchant data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchant: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merchants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invite a merchant account team
         * @param {string} merchantId 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMerchant: async (merchantId: string, inlineObject1: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantId' is not null or undefined
            assertParamExists('inviteMerchant', 'merchantId', merchantId)
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('inviteMerchant', 'inlineObject1', inlineObject1)
            const localVarPath = `/merchants/{merchantId}/invite`
                .replace(`{${"merchantId"}}`, encodeURIComponent(String(merchantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply both the id token for the account, aswell as the access token, which would have been provided to you, through a link or email.
         * @summary Join a merchant account team
         * @param {string} merchantId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinMerchant: async (merchantId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantId' is not null or undefined
            assertParamExists('joinMerchant', 'merchantId', merchantId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('joinMerchant', 'key', key)
            const localVarPath = `/merchants/{merchantId}/join`
                .replace(`{${"merchantId"}}`, encodeURIComponent(String(merchantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange an account access token to get a resource token Which gives access to all the merhant scopes you have permission for
         * @summary Login to a merchant account
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMerchant: async (merchantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantId' is not null or undefined
            assertParamExists('loginMerchant', 'merchantId', merchantId)
            const localVarPath = `/merchants/{merchantId}/token`
                .replace(`{${"merchantId"}}`, encodeURIComponent(String(merchantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply a merchant JWT token and email parameters to send an email through the handsin email service
         * @summary Send an email
         * @param {EmailCreationParams} emailCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailMerchant: async (emailCreationParams: EmailCreationParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailCreationParams' is not null or undefined
            assertParamExists('sendEmailMerchant', 'emailCreationParams', emailCreationParams)
            const localVarPath = `/merchants/sendEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailCreationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantApi - functional programming interface
 * @export
 */
export const MerchantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MerchantApiAxiosParamCreator(configuration)
    return {
        /**
         * Provide a ID token to create a merchant. Receive a JWT access token that gives all scope to account.
         * @summary Create a merchant account
         * @param {PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMerchant(body: PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMerchant(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a merchant account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMerchant(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMerchant(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply a merchant JWT token and retrieve merchant data
         * @summary Retrieve merchant data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerchant(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerchant(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invite a merchant account team
         * @param {string} merchantId 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteMerchant(merchantId: string, inlineObject1: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteMerchant(merchantId, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply both the id token for the account, aswell as the access token, which would have been provided to you, through a link or email.
         * @summary Join a merchant account team
         * @param {string} merchantId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinMerchant(merchantId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinMerchant(merchantId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Exchange an account access token to get a resource token Which gives access to all the merhant scopes you have permission for
         * @summary Login to a merchant account
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginMerchant(merchantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginMerchant(merchantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply a merchant JWT token and email parameters to send an email through the handsin email service
         * @summary Send an email
         * @param {EmailCreationParams} emailCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmailMerchant(emailCreationParams: EmailCreationParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Email>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmailMerchant(emailCreationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MerchantApi - factory interface
 * @export
 */
export const MerchantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MerchantApiFp(configuration)
    return {
        /**
         * Provide a ID token to create a merchant. Receive a JWT access token that gives all scope to account.
         * @summary Create a merchant account
         * @param {PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchant(body: PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency, options?: any): AxiosPromise<MerchantDTO> {
            return localVarFp.createMerchant(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a merchant account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchant(options?: any): AxiosPromise<MerchantDTO> {
            return localVarFp.deleteMerchant(options).then((request) => request(axios, basePath));
        },
        /**
         * Supply a merchant JWT token and retrieve merchant data
         * @summary Retrieve merchant data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchant(options?: any): AxiosPromise<MerchantDTO> {
            return localVarFp.getMerchant(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invite a merchant account team
         * @param {string} merchantId 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMerchant(merchantId: string, inlineObject1: InlineObject1, options?: any): AxiosPromise<MerchantDTO> {
            return localVarFp.inviteMerchant(merchantId, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply both the id token for the account, aswell as the access token, which would have been provided to you, through a link or email.
         * @summary Join a merchant account team
         * @param {string} merchantId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinMerchant(merchantId: string, key: string, options?: any): AxiosPromise<MerchantDTO> {
            return localVarFp.joinMerchant(merchantId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange an account access token to get a resource token Which gives access to all the merhant scopes you have permission for
         * @summary Login to a merchant account
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMerchant(merchantId: string, options?: any): AxiosPromise<OAuthTokenResponse> {
            return localVarFp.loginMerchant(merchantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply a merchant JWT token and email parameters to send an email through the handsin email service
         * @summary Send an email
         * @param {EmailCreationParams} emailCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailMerchant(emailCreationParams: EmailCreationParams, options?: any): AxiosPromise<Email> {
            return localVarFp.sendEmailMerchant(emailCreationParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MerchantApi - object-oriented interface
 * @export
 * @class MerchantApi
 * @extends {BaseAPI}
 */
export class MerchantApi extends BaseAPI {
    /**
     * Provide a ID token to create a merchant. Receive a JWT access token that gives all scope to account.
     * @summary Create a merchant account
     * @param {PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public createMerchant(body: PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency, options?: AxiosRequestConfig) {
        return MerchantApiFp(this.configuration).createMerchant(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a merchant account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public deleteMerchant(options?: AxiosRequestConfig) {
        return MerchantApiFp(this.configuration).deleteMerchant(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply a merchant JWT token and retrieve merchant data
     * @summary Retrieve merchant data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public getMerchant(options?: AxiosRequestConfig) {
        return MerchantApiFp(this.configuration).getMerchant(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invite a merchant account team
     * @param {string} merchantId 
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public inviteMerchant(merchantId: string, inlineObject1: InlineObject1, options?: AxiosRequestConfig) {
        return MerchantApiFp(this.configuration).inviteMerchant(merchantId, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply both the id token for the account, aswell as the access token, which would have been provided to you, through a link or email.
     * @summary Join a merchant account team
     * @param {string} merchantId 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public joinMerchant(merchantId: string, key: string, options?: AxiosRequestConfig) {
        return MerchantApiFp(this.configuration).joinMerchant(merchantId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange an account access token to get a resource token Which gives access to all the merhant scopes you have permission for
     * @summary Login to a merchant account
     * @param {string} merchantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public loginMerchant(merchantId: string, options?: AxiosRequestConfig) {
        return MerchantApiFp(this.configuration).loginMerchant(merchantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply a merchant JWT token and email parameters to send an email through the handsin email service
     * @summary Send an email
     * @param {EmailCreationParams} emailCreationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public sendEmailMerchant(emailCreationParams: EmailCreationParams, options?: AxiosRequestConfig) {
        return MerchantApiFp(this.configuration).sendEmailMerchant(emailCreationParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MerchantConnectApi - axios parameter creator
 * @export
 */
export const MerchantConnectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Redirect merchant to payment service (e.g. square) authorisation page and connect service via Merchant Payment Connector
         * @summary Connect to Merchant Payment Service
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authoriseMerchantPaymentConnect: async (service: Service, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'service' is not null or undefined
            assertParamExists('authoriseMerchantPaymentConnect', 'service', service)
            const localVarPath = `/merchant/{service}/connect`
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Connection to Merchant Payment Service Properties
         * @summary Get Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantPaymentConnect: async (service: Service, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'service' is not null or undefined
            assertParamExists('getMerchantPaymentConnect', 'service', service)
            const localVarPath = `/merchant/{service}`
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain access token for merchant payment service account This is automatically hit by redirect url after authorizing payment service
         * @summary Obtain Merchant Payment Connection
         * @param {Service} service 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainMerchantPaymentConnect: async (service: Service, code?: string, state?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'service' is not null or undefined
            assertParamExists('obtainMerchantPaymentConnect', 'service', service)
            const localVarPath = `/merchant/{service}/obtain`
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-Authorise Connection to Merchant Payment Service
         * @summary Renew Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewMerchantPaymentConnect: async (service: Service, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'service' is not null or undefined
            assertParamExists('renewMerchantPaymentConnect', 'service', service)
            const localVarPath = `/merchant/{service}/renew`
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke Connection Tokens to Merchant Payment Service
         * @summary Revoke Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMerchantPaymentConnect: async (service: Service, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'service' is not null or undefined
            assertParamExists('revokeMerchantPaymentConnect', 'service', service)
            const localVarPath = `/merchant/{service}/revoke`
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantConnectApi - functional programming interface
 * @export
 */
export const MerchantConnectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MerchantConnectApiAxiosParamCreator(configuration)
    return {
        /**
         * Redirect merchant to payment service (e.g. square) authorisation page and connect service via Merchant Payment Connector
         * @summary Connect to Merchant Payment Service
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authoriseMerchantPaymentConnect(service: Service, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authoriseMerchantPaymentConnect(service, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Connection to Merchant Payment Service Properties
         * @summary Get Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerchantPaymentConnect(service: Service, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerchantPaymentConnect(service, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Obtain access token for merchant payment service account This is automatically hit by redirect url after authorizing payment service
         * @summary Obtain Merchant Payment Connection
         * @param {Service} service 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtainMerchantPaymentConnect(service: Service, code?: string, state?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtainMerchantPaymentConnect(service, code, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Re-Authorise Connection to Merchant Payment Service
         * @summary Renew Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renewMerchantPaymentConnect(service: Service, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renewMerchantPaymentConnect(service, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Revoke Connection Tokens to Merchant Payment Service
         * @summary Revoke Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeMerchantPaymentConnect(service: Service, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeMerchantPaymentConnect(service, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MerchantConnectApi - factory interface
 * @export
 */
export const MerchantConnectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MerchantConnectApiFp(configuration)
    return {
        /**
         * Redirect merchant to payment service (e.g. square) authorisation page and connect service via Merchant Payment Connector
         * @summary Connect to Merchant Payment Service
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authoriseMerchantPaymentConnect(service: Service, options?: any): AxiosPromise<string> {
            return localVarFp.authoriseMerchantPaymentConnect(service, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Connection to Merchant Payment Service Properties
         * @summary Get Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantPaymentConnect(service: Service, options?: any): AxiosPromise<ConnectRecord> {
            return localVarFp.getMerchantPaymentConnect(service, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain access token for merchant payment service account This is automatically hit by redirect url after authorizing payment service
         * @summary Obtain Merchant Payment Connection
         * @param {Service} service 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainMerchantPaymentConnect(service: Service, code?: string, state?: string, options?: any): AxiosPromise<void> {
            return localVarFp.obtainMerchantPaymentConnect(service, code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Re-Authorise Connection to Merchant Payment Service
         * @summary Renew Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewMerchantPaymentConnect(service: Service, options?: any): AxiosPromise<ConnectRecord> {
            return localVarFp.renewMerchantPaymentConnect(service, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke Connection Tokens to Merchant Payment Service
         * @summary Revoke Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMerchantPaymentConnect(service: Service, options?: any): AxiosPromise<void> {
            return localVarFp.revokeMerchantPaymentConnect(service, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MerchantConnectApi - object-oriented interface
 * @export
 * @class MerchantConnectApi
 * @extends {BaseAPI}
 */
export class MerchantConnectApi extends BaseAPI {
    /**
     * Redirect merchant to payment service (e.g. square) authorisation page and connect service via Merchant Payment Connector
     * @summary Connect to Merchant Payment Service
     * @param {Service} service 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantConnectApi
     */
    public authoriseMerchantPaymentConnect(service: Service, options?: AxiosRequestConfig) {
        return MerchantConnectApiFp(this.configuration).authoriseMerchantPaymentConnect(service, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Connection to Merchant Payment Service Properties
     * @summary Get Merchant Payment Connection
     * @param {Service} service 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantConnectApi
     */
    public getMerchantPaymentConnect(service: Service, options?: AxiosRequestConfig) {
        return MerchantConnectApiFp(this.configuration).getMerchantPaymentConnect(service, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain access token for merchant payment service account This is automatically hit by redirect url after authorizing payment service
     * @summary Obtain Merchant Payment Connection
     * @param {Service} service 
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantConnectApi
     */
    public obtainMerchantPaymentConnect(service: Service, code?: string, state?: string, options?: AxiosRequestConfig) {
        return MerchantConnectApiFp(this.configuration).obtainMerchantPaymentConnect(service, code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Re-Authorise Connection to Merchant Payment Service
     * @summary Renew Merchant Payment Connection
     * @param {Service} service 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantConnectApi
     */
    public renewMerchantPaymentConnect(service: Service, options?: AxiosRequestConfig) {
        return MerchantConnectApiFp(this.configuration).renewMerchantPaymentConnect(service, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke Connection Tokens to Merchant Payment Service
     * @summary Revoke Merchant Payment Connection
     * @param {Service} service 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantConnectApi
     */
    public revokeMerchantPaymentConnect(service: Service, options?: AxiosRequestConfig) {
        return MerchantConnectApiFp(this.configuration).revokeMerchantPaymentConnect(service, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an order
         * @param {OrderCreationParams} orderCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (orderCreationParams: OrderCreationParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderCreationParams' is not null or undefined
            assertParamExists('createOrder', 'orderCreationParams', orderCreationParams)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCreationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Orders
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders: async (pageNum?: number, pageSize?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an order
         * @param {string} orderId 
         * @param {PartialOrderCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder: async (orderId: string, body: PartialOrderCreationParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('updateOrder', 'orderId', orderId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateOrder', 'body', body)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an order
         * @param {OrderCreationParams} orderCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(orderCreationParams: OrderCreationParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(orderCreationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Orders
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrders(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrders(pageNum, pageSize, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an order
         * @param {string} orderId 
         * @param {PartialOrderCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrder(orderId: string, body: PartialOrderCreationParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder(orderId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an order
         * @param {OrderCreationParams} orderCreationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(orderCreationParams: OrderCreationParams, options?: any): AxiosPromise<Order> {
            return localVarFp.createOrder(orderCreationParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, options?: any): AxiosPromise<Order> {
            return localVarFp.getOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Orders
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(pageNum?: number, pageSize?: number, limit?: number, options?: any): AxiosPromise<Array<Order>> {
            return localVarFp.listOrders(pageNum, pageSize, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an order
         * @param {string} orderId 
         * @param {PartialOrderCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(orderId: string, body: PartialOrderCreationParams, options?: any): AxiosPromise<Order> {
            return localVarFp.updateOrder(orderId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @summary Create an order
     * @param {OrderCreationParams} orderCreationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public createOrder(orderCreationParams: OrderCreationParams, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).createOrder(orderCreationParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an order
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrder(orderId: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Orders
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public listOrders(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).listOrders(pageNum, pageSize, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an order
     * @param {string} orderId 
     * @param {PartialOrderCreationParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public updateOrder(orderId: string, body: PartialOrderCreationParams, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).updateOrder(orderId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment: async (paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('cancelPayment', 'paymentId', paymentId)
            const localVarPath = `/payments/{paymentId}/cancel`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Collect a payment from an individual user
         * @summary Create a payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment: async (createPaymentRequest: CreatePaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentRequest' is not null or undefined
            assertParamExists('createPayment', 'createPaymentRequest', createPaymentRequest)
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique payment ID and receive corresponding payment details.
         * @summary Retrieve a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: async (paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPayment', 'paymentId', paymentId)
            const localVarPath = `/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all payment refunds
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentRefunds: async (paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPaymentRefunds', 'paymentId', paymentId)
            const localVarPath = `/payments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all payments
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments: async (pageNum?: number, pageSize?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a full or partial refund back to a customer, from a supplied payment.
         * @summary Refund a payment
         * @param {string} paymentId 
         * @param {PaymentRefundRequest} paymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment: async (paymentId: string, paymentRefundRequest: PaymentRefundRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('refundPayment', 'paymentId', paymentId)
            // verify required parameter 'paymentRefundRequest' is not null or undefined
            assertParamExists('refundPayment', 'paymentRefundRequest', paymentRefundRequest)
            const localVarPath = `/payments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentRefundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPayment(paymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPayment(paymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Collect a payment from an individual user
         * @summary Create a payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayment(createPaymentRequest: CreatePaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(createPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply the unique payment ID and receive corresponding payment details.
         * @summary Retrieve a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayment(paymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(paymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all payment refunds
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentRefunds(paymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentRefunds(paymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all payments
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayments(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayments(pageNum, pageSize, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a full or partial refund back to a customer, from a supplied payment.
         * @summary Refund a payment
         * @param {string} paymentId 
         * @param {PaymentRefundRequest} paymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundPayment(paymentId: string, paymentRefundRequest: PaymentRefundRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundPayment(paymentId, paymentRefundRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment(paymentId: string, options?: any): AxiosPromise<PaymentRecord> {
            return localVarFp.cancelPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Collect a payment from an individual user
         * @summary Create a payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(createPaymentRequest: CreatePaymentRequest, options?: any): AxiosPromise<PaymentRecord> {
            return localVarFp.createPayment(createPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply the unique payment ID and receive corresponding payment details.
         * @summary Retrieve a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId: string, options?: any): AxiosPromise<PaymentRecord> {
            return localVarFp.getPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all payment refunds
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentRefunds(paymentId: string, options?: any): AxiosPromise<Array<RefundRecord>> {
            return localVarFp.getPaymentRefunds(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all payments
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(pageNum?: number, pageSize?: number, limit?: number, options?: any): AxiosPromise<Array<PaymentRecord>> {
            return localVarFp.listPayments(pageNum, pageSize, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a full or partial refund back to a customer, from a supplied payment.
         * @summary Refund a payment
         * @param {string} paymentId 
         * @param {PaymentRefundRequest} paymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(paymentId: string, paymentRefundRequest: PaymentRefundRequest, options?: any): AxiosPromise<RefundRecord> {
            return localVarFp.refundPayment(paymentId, paymentRefundRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Cancel a payment
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public cancelPayment(paymentId: string, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).cancelPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Collect a payment from an individual user
     * @summary Create a payment
     * @param {CreatePaymentRequest} createPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createPayment(createPaymentRequest: CreatePaymentRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).createPayment(createPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply the unique payment ID and receive corresponding payment details.
     * @summary Retrieve a payment
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPayment(paymentId: string, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all payment refunds
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPaymentRefunds(paymentId: string, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getPaymentRefunds(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all payments
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public listPayments(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).listPayments(pageNum, pageSize, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a full or partial refund back to a customer, from a supplied payment.
     * @summary Refund a payment
     * @param {string} paymentId 
     * @param {PaymentRefundRequest} paymentRefundRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public refundPayment(paymentId: string, paymentRefundRequest: PaymentRefundRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).refundPayment(paymentId, paymentRefundRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RefundsApi - axios parameter creator
 * @export
 */
export const RefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a refund
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefund: async (refundId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundId' is not null or undefined
            assertParamExists('getRefund', 'refundId', refundId)
            const localVarPath = `/refunds/{refundId}`
                .replace(`{${"refundId"}}`, encodeURIComponent(String(refundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all refunds
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds: async (pageNum?: number, pageSize?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication merchant-jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefundsApi - functional programming interface
 * @export
 */
export const RefundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a refund
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefund(refundId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefund(refundId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all refunds
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRefunds(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRefunds(pageNum, pageSize, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RefundsApi - factory interface
 * @export
 */
export const RefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefundsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a refund
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefund(refundId: string, options?: any): AxiosPromise<RefundRecord> {
            return localVarFp.getRefund(refundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all refunds
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(pageNum?: number, pageSize?: number, limit?: number, options?: any): AxiosPromise<Array<RefundRecord>> {
            return localVarFp.listRefunds(pageNum, pageSize, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefundsApi - object-oriented interface
 * @export
 * @class RefundsApi
 * @extends {BaseAPI}
 */
export class RefundsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a refund
     * @param {string} refundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public getRefund(refundId: string, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).getRefund(refundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all refunds
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public listRefunds(pageNum?: number, pageSize?: number, limit?: number, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).listRefunds(pageNum, pageSize, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


