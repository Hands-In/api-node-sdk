/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Merchant API
 * The Hands In API is the first and only service that enables users to transact within a group. Our API is heavily orientated around being a RESTful service  that has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, ant utilizes standard HTTP response codes
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://sandbox.handsin.co.uk/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ACHDetails
 */
export interface ACHDetails {
    /**
     * The routing number for the bank account.
     * @type {string}
     * @memberof ACHDetails
     */
    routingNumber?: string;
    /**
     * The last few digits of the bank account number.
     * @type {string}
     * @memberof ACHDetails
     */
    accountNumberSuffix?: string;
    /**
     * The type of the bank account performing the transfer. The account type can be `CHECKING`, `SAVINGS`, or `UNKNOWN`.
     * @type {string}
     * @memberof ACHDetails
     */
    accountType?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AVSStatus {
    ACCEPTED = <any> 'AVS_ACCEPTED',
    REJECTED = <any> 'AVS_REJECTED',
    NOTCHECKED = <any> 'AVS_NOT_CHECKED'
}
/**
 * 
 * @export
 * @interface AccountApp
 */
export interface AccountApp {
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    accId: string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    appId: string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    appName: string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface AccountCreationParams
 */
export interface AccountCreationParams {
    /**
     * 
     * @type {EmailAddress}
     * @memberof AccountCreationParams
     */
    email: EmailAddress;
    /**
     * 
     * @type {Password}
     * @memberof AccountCreationParams
     */
    password: Password;
    /**
     * 
     * @type {string}
     * @memberof AccountCreationParams
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof AccountCreationParams
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountCreationParams
     */
    language?: string;
    /**
     * 
     * @type {Country}
     * @memberof AccountCreationParams
     */
    country?: Country;
}
/**
 * 
 * @export
 * @interface AccountDTO
 */
export interface AccountDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    email: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountDTO
     */
    emailVerified: boolean;
    /**
     * 
     * @type {Country}
     * @memberof AccountDTO
     */
    country?: Country;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    language?: string;
    /**
     * 
     * @type {Date}
     * @memberof AccountDTO
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AccountDTO
     */
    updatedAt?: Date;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {AddressLines}
     * @memberof Address
     */
    addressLines: AddressLines;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * 
     * @type {Country}
     * @memberof Address
     */
    country?: Country;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    postalCode?: string;
    /**
     * 
     * @type {Sublocality}
     * @memberof Address
     */
    sublocality?: Sublocality;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    organization?: string;
}
/**
 * 
 * @export
 * @interface AddressLines
 */
export interface AddressLines {
    /**
     * 
     * @type {string}
     * @memberof AddressLines
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof AddressLines
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressLines
     */
    addressLine3?: string;
}
/**
 * 
 * @export
 * @interface AdjustableQuantity
 */
export interface AdjustableQuantity {
    /**
     * 
     * @type {ModelInteger}
     * @memberof AdjustableQuantity
     */
    minimum: ModelInteger;
    /**
     * 
     * @type {ModelInteger}
     * @memberof AdjustableQuantity
     */
    maxmimum: ModelInteger;
}
/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    filename?: string;
}
/**
 * Key-value pairs that help to differentiate variants
 * @export
 * @interface Attributes
 */
export interface Attributes extends null<String, string> {
    [key: string]: string;

}
/**
 * 
 * @export
 * @interface BankAccountPaymentDetails
 */
export interface BankAccountPaymentDetails {
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    bankName?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    transferType?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    accountOwnershipType?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountPaymentDetails
     */
    statementDescription?: string;
    /**
     * 
     * @type {ACHDetails}
     * @memberof BankAccountPaymentDetails
     */
    achDetails?: ACHDetails;
    /**
     * 
     * @type {Array<PaymentError>}
     * @memberof BankAccountPaymentDetails
     */
    errors?: Array<PaymentError>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CVVStatus {
    ACCEPTED = <any> 'CVV_ACCEPTED',
    REJECTED = <any> 'CVV_REJECTED',
    NOTCHECKED = <any> 'CVV_NOT_CHECKED'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CaptureMethod {
    PAYMENT = <any> 'PAYMENT',
    CAPTURE = <any> 'CAPTURE',
    SUBSCRIPTION = <any> 'SUBSCRIPTION'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CardBrand {
    OTHERBRAND = <any> 'OTHER_BRAND',
    VISA = <any> 'VISA',
    MASTERCARD = <any> 'MASTERCARD',
    AMERICANEXPRESS = <any> 'AMERICAN_EXPRESS',
    DISCOVER = <any> 'DISCOVER',
    DISCOVERDINERS = <any> 'DISCOVER_DINERS',
    JCB = <any> 'JCB',
    CHINAUNIONPAY = <any> 'CHINA_UNIONPAY',
    SQUAREGIFTCARD = <any> 'SQUARE_GIFT_CARD',
    SQUARECAPITALCARD = <any> 'SQUARE_CAPITAL_CARD',
    INTERAC = <any> 'INTERAC',
    EFTPOS = <any> 'EFTPOS',
    FELICA = <any> 'FELICA',
    EBT = <any> 'EBT'
}
/**
 * 
 * @export
 * @interface CardDetails
 */
export interface CardDetails {
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    id: string;
    /**
     * 
     * @type {CardBrand}
     * @memberof CardDetails
     */
    cardBrand: CardBrand;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    last4?: string;
    /**
     * 
     * @type {ModelInteger}
     * @memberof CardDetails
     */
    expMonth?: ModelInteger;
    /**
     * 
     * @type {ModelInteger}
     * @memberof CardDetails
     */
    expYear?: ModelInteger;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    cardholderName?: string;
    /**
     * 
     * @type {Address}
     * @memberof CardDetails
     */
    billingAddress?: Address;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    customerId?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    referenceId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardDetails
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    cardType?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    prepaidType?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    bin?: string;
}
/**
 * 
 * @export
 * @interface CardPaymentDetails
 */
export interface CardPaymentDetails {
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    status?: string;
    /**
     * 
     * @type {CardDetails}
     * @memberof CardPaymentDetails
     */
    card?: CardDetails;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    entryMethod?: string;
    /**
     * 
     * @type {CVVStatus}
     * @memberof CardPaymentDetails
     */
    cvvStatus?: CVVStatus;
    /**
     * 
     * @type {AVSStatus}
     * @memberof CardPaymentDetails
     */
    avsStatus?: AVSStatus;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    authResultCode?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    applicationIdentifier?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    applicationName?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    applicationCryptogram?: string;
    /**
     * 
     * @type {CardVerificationMethod}
     * @memberof CardPaymentDetails
     */
    verificationMethod?: CardVerificationMethod;
    /**
     * 
     * @type {CardVerificationResult}
     * @memberof CardPaymentDetails
     */
    verificationResults?: CardVerificationResult;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    statementDescription?: string;
    /**
     * 
     * @type {DeviceDetails}
     * @memberof CardPaymentDetails
     */
    deviceDetails?: DeviceDetails;
    /**
     * 
     * @type {CardPaymentTimeline}
     * @memberof CardPaymentDetails
     */
    cardPaymentTimeline?: CardPaymentTimeline;
    /**
     * 
     * @type {boolean}
     * @memberof CardPaymentDetails
     */
    refundRequiresCardPresence?: boolean;
    /**
     * Information about errors encountered during the request.
     * @type {Array<PaymentError>}
     * @memberof CardPaymentDetails
     */
    errors?: Array<PaymentError>;
}
/**
 * 
 * @export
 * @interface CardPaymentTimeline
 */
export interface CardPaymentTimeline {
    /**
     * 
     * @type {string}
     * @memberof CardPaymentTimeline
     */
    authorizedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentTimeline
     */
    capturedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentTimeline
     */
    voidedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CardVerificationMethod {
    PIN = <any> 'PIN',
    PINANDSIGNATURE = <any> 'PIN_AND_SIGNATURE',
    SIGNATURE = <any> 'SIGNATURE',
    ONDEVICE = <any> 'ON_DEVICE',
    NONE = <any> 'NONE'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CardVerificationResult {
    SUCCESS = <any> 'SUCCESS',
    FAILURE = <any> 'FAILURE',
    UNKNOWN = <any> 'UNKNOWN'
}
/**
 * 
 * @export
 * @interface CashPaymentDetails
 */
export interface CashPaymentDetails {
    /**
     * 
     * @type {Money}
     * @memberof CashPaymentDetails
     */
    buyerSuppliedMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof CashPaymentDetails
     */
    changeBackMoney?: Money;
}
/**
 * 
 * @export
 * @interface CheckoutLineItemCreationParam
 */
export interface CheckoutLineItemCreationParam {
    /**
     * Item can be created inline if neccessary
     * @type {string | ItemCreationParams}
     * @memberof CheckoutLineItemCreationParam
     */
    item: string | ItemCreationParams;
    /**
     * 
     * @type {ModelInteger}
     * @memberof CheckoutLineItemCreationParam
     */
    quantity: ModelInteger;
    /**
     * 
     * @type {AdjustableQuantity}
     * @memberof CheckoutLineItemCreationParam
     */
    adjustableQuantity?: AdjustableQuantity;
}
/**
 * 
 * @export
 * @interface CheckoutPageOptions
 */
export interface CheckoutPageOptions {
    /**
     * 
     * @type {CaptureMethod}
     * @memberof CheckoutPageOptions
     */
    captureMethod: CaptureMethod;
    /**
     * 
     * @type {Url}
     * @memberof CheckoutPageOptions
     */
    successUrl?: Url;
    /**
     * 
     * @type {Url}
     * @memberof CheckoutPageOptions
     */
    cancelUrl?: Url;
    /**
     * 
     * @type {Url}
     * @memberof CheckoutPageOptions
     */
    expireUrl?: Url;
    /**
     * 
     * @type {ModelBoolean}
     * @memberof CheckoutPageOptions
     */
    enableGroupPayments?: ModelBoolean;
    /**
     * 
     * @type {ModelBoolean}
     * @memberof CheckoutPageOptions
     */
    enableTips?: ModelBoolean;
    /**
     * 
     * @type {ModelBoolean}
     * @memberof CheckoutPageOptions
     */
    enableDiscounts?: ModelBoolean;
    /**
     * Will pre-apply an array of discount codes Discounts have to be enabled first.
     * @type {Array<string>}
     * @memberof CheckoutPageOptions
     */
    discountCodes?: Array<string>;
    /**
     * 
     * @type {Array<PaymentMethod>}
     * @memberof CheckoutPageOptions
     */
    paymentMethods?: Array<PaymentMethod>;
    /**
     * 
     * @type {CheckoutStyle}
     * @memberof CheckoutPageOptions
     */
    style?: CheckoutStyle;
    /**
     * 
     * @type {ModelBoolean}
     * @memberof CheckoutPageOptions
     */
    showEditItemsPage?: ModelBoolean;
}
/**
 * 
 * @export
 * @interface CheckoutSession
 */
export interface CheckoutSession {
    /**
     * 
     * @type {string}
     * @memberof CheckoutSession
     */
    id: string;
    /**
     * 
     * @type {CheckoutStatus}
     * @memberof CheckoutSession
     */
    status: CheckoutStatus;
    /**
     * 
     * @type {Date}
     * @memberof CheckoutSession
     */
    expirationDate: Date;
    /**
     * User will populate data in checkout session if provided
     * @type {string}
     * @memberof CheckoutSession
     */
    customerId?: string;
    /**
     * The order associated with the checkout session
     * @type {string}
     * @memberof CheckoutSession
     */
    orderId: string;
    /**
     * The payment associated with the checkout session Could be either single payment or group payment
     * @type {string}
     * @memberof CheckoutSession
     */
    paymentId?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSession
     */
    groupPaymentId?: string;
    /**
     * 
     * @type {CheckoutPageOptions}
     * @memberof CheckoutSession
     */
    checkoutOptions: CheckoutPageOptions;
    /**
     * 
     * @type {Url}
     * @memberof CheckoutSession
     */
    url: Url;
    /**
     * 
     * @type {Date}
     * @memberof CheckoutSession
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CheckoutSession
     */
    updatedAt?: Date;
    /**
     * 
     * @type {number}
     * @memberof CheckoutSession
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSession
     */
    referenceId?: string;
    /**
     * 
     * @type {MetaData}
     * @memberof CheckoutSession
     */
    metaData?: MetaData;
}
/**
 * 
 * @export
 * @interface CheckoutSessionCreationParams
 */
export interface CheckoutSessionCreationParams {
    /**
     * 
     * @type {Array<CheckoutLineItemCreationParam>}
     * @memberof CheckoutSessionCreationParams
     */
    lineItemParams: Array<CheckoutLineItemCreationParam>;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionCreationParams
     */
    referenceId?: string;
    /**
     * 
     * @type {CustomerCreationParams | string}
     * @memberof CheckoutSessionCreationParams
     */
    customer?: CustomerCreationParams | string;
    /**
     * 
     * @type {Date}
     * @memberof CheckoutSessionCreationParams
     */
    expirationDate?: Date;
    /**
     * 
     * @type {CheckoutPageOptions}
     * @memberof CheckoutSessionCreationParams
     */
    checkoutPageOptions: CheckoutPageOptions;
    /**
     * 
     * @type {MetaData}
     * @memberof CheckoutSessionCreationParams
     */
    metaData?: MetaData;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CheckoutStatus {
    EXPIRED = <any> 'EXPIRED',
    CANCELLED = <any> 'CANCELLED',
    PENDING = <any> 'PENDING'
}
/**
 * 
 * @export
 * @interface CheckoutStyle
 */
export interface CheckoutStyle {
    /**
     * 
     * @type {string}
     * @memberof CheckoutStyle
     */
    secondaryColor: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutStyle
     */
    primaryColor: string;
}
/**
 * 
 * @export
 * @interface ClientCreationParams
 */
export interface ClientCreationParams {
    /**
     * 
     * @type {string}
     * @memberof ClientCreationParams
     */
    name: string;
    /**
     * 
     * @type {Url}
     * @memberof ClientCreationParams
     */
    logoUrl?: Url;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientCreationParams
     */
    redirectUris?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientCreationParams
     */
    scopes: Array<string>;
}
/**
 * Client response will automatically give bool values determining if client is verified or not
 * @export
 * @interface ClientResponse
 */
export interface ClientResponse extends OmitClientVerifiedSigOrTrustedSig_ {
    /**
     * 
     * @type {boolean}
     * @memberof ClientResponse
     */
    verified: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientResponse
     */
    trusted: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Country {
    AF = <any> 'AF',
    AX = <any> 'AX',
    AL = <any> 'AL',
    DZ = <any> 'DZ',
    AS = <any> 'AS',
    AD = <any> 'AD',
    AO = <any> 'AO',
    AI = <any> 'AI',
    AQ = <any> 'AQ',
    AG = <any> 'AG',
    AR = <any> 'AR',
    AM = <any> 'AM',
    AW = <any> 'AW',
    AU = <any> 'AU',
    AT = <any> 'AT',
    AZ = <any> 'AZ',
    BS = <any> 'BS',
    BH = <any> 'BH',
    BD = <any> 'BD',
    BB = <any> 'BB',
    BY = <any> 'BY',
    BE = <any> 'BE',
    BZ = <any> 'BZ',
    BJ = <any> 'BJ',
    BM = <any> 'BM',
    BT = <any> 'BT',
    BO = <any> 'BO',
    BQ = <any> 'BQ',
    BA = <any> 'BA',
    BW = <any> 'BW',
    BV = <any> 'BV',
    BR = <any> 'BR',
    IO = <any> 'IO',
    BN = <any> 'BN',
    BG = <any> 'BG',
    BF = <any> 'BF',
    BI = <any> 'BI',
    KH = <any> 'KH',
    CM = <any> 'CM',
    CA = <any> 'CA',
    CV = <any> 'CV',
    KY = <any> 'KY',
    CF = <any> 'CF',
    TD = <any> 'TD',
    CL = <any> 'CL',
    CN = <any> 'CN',
    CX = <any> 'CX',
    CC = <any> 'CC',
    CO = <any> 'CO',
    KM = <any> 'KM',
    CG = <any> 'CG',
    CD = <any> 'CD',
    CK = <any> 'CK',
    CR = <any> 'CR',
    CI = <any> 'CI',
    HR = <any> 'HR',
    CU = <any> 'CU',
    CW = <any> 'CW',
    CY = <any> 'CY',
    CZ = <any> 'CZ',
    DK = <any> 'DK',
    DJ = <any> 'DJ',
    DM = <any> 'DM',
    DO = <any> 'DO',
    EC = <any> 'EC',
    EG = <any> 'EG',
    SV = <any> 'SV',
    GQ = <any> 'GQ',
    ER = <any> 'ER',
    EE = <any> 'EE',
    ET = <any> 'ET',
    FK = <any> 'FK',
    FO = <any> 'FO',
    FJ = <any> 'FJ',
    FI = <any> 'FI',
    FR = <any> 'FR',
    GF = <any> 'GF',
    PF = <any> 'PF',
    TF = <any> 'TF',
    GA = <any> 'GA',
    GM = <any> 'GM',
    GE = <any> 'GE',
    DE = <any> 'DE',
    GH = <any> 'GH',
    GI = <any> 'GI',
    GR = <any> 'GR',
    GL = <any> 'GL',
    GD = <any> 'GD',
    GP = <any> 'GP',
    GU = <any> 'GU',
    GT = <any> 'GT',
    GG = <any> 'GG',
    GN = <any> 'GN',
    GW = <any> 'GW',
    GY = <any> 'GY',
    HT = <any> 'HT',
    HM = <any> 'HM',
    VA = <any> 'VA',
    HN = <any> 'HN',
    HK = <any> 'HK',
    HU = <any> 'HU',
    IS = <any> 'IS',
    IN = <any> 'IN',
    ID = <any> 'ID',
    IR = <any> 'IR',
    IQ = <any> 'IQ',
    IE = <any> 'IE',
    IM = <any> 'IM',
    IL = <any> 'IL',
    IT = <any> 'IT',
    JM = <any> 'JM',
    JP = <any> 'JP',
    JE = <any> 'JE',
    JO = <any> 'JO',
    KZ = <any> 'KZ',
    KE = <any> 'KE',
    KI = <any> 'KI',
    KR = <any> 'KR',
    KP = <any> 'KP',
    KW = <any> 'KW',
    KG = <any> 'KG',
    LA = <any> 'LA',
    LV = <any> 'LV',
    LB = <any> 'LB',
    LS = <any> 'LS',
    LR = <any> 'LR',
    LY = <any> 'LY',
    LI = <any> 'LI',
    LT = <any> 'LT',
    LU = <any> 'LU',
    MO = <any> 'MO',
    MK = <any> 'MK',
    MG = <any> 'MG',
    MW = <any> 'MW',
    MY = <any> 'MY',
    MV = <any> 'MV',
    ML = <any> 'ML',
    MT = <any> 'MT',
    MH = <any> 'MH',
    MQ = <any> 'MQ',
    MR = <any> 'MR',
    MU = <any> 'MU',
    YT = <any> 'YT',
    MX = <any> 'MX',
    FM = <any> 'FM',
    MD = <any> 'MD',
    MC = <any> 'MC',
    MN = <any> 'MN',
    ME = <any> 'ME',
    MS = <any> 'MS',
    MA = <any> 'MA',
    MZ = <any> 'MZ',
    MM = <any> 'MM',
    NA = <any> 'NA',
    NR = <any> 'NR',
    NP = <any> 'NP',
    NL = <any> 'NL',
    NC = <any> 'NC',
    NZ = <any> 'NZ',
    NI = <any> 'NI',
    NE = <any> 'NE',
    NG = <any> 'NG',
    NU = <any> 'NU',
    NF = <any> 'NF',
    MP = <any> 'MP',
    False = <any> 'false',
    OM = <any> 'OM',
    PK = <any> 'PK',
    PW = <any> 'PW',
    PS = <any> 'PS',
    PA = <any> 'PA',
    PG = <any> 'PG',
    PY = <any> 'PY',
    PE = <any> 'PE',
    PH = <any> 'PH',
    PN = <any> 'PN',
    PL = <any> 'PL',
    PT = <any> 'PT',
    PR = <any> 'PR',
    QA = <any> 'QA',
    RE = <any> 'RE',
    RO = <any> 'RO',
    RU = <any> 'RU',
    RW = <any> 'RW',
    BL = <any> 'BL',
    SH = <any> 'SH',
    KN = <any> 'KN',
    LC = <any> 'LC',
    MF = <any> 'MF',
    PM = <any> 'PM',
    VC = <any> 'VC',
    WS = <any> 'WS',
    SM = <any> 'SM',
    ST = <any> 'ST',
    SA = <any> 'SA',
    SN = <any> 'SN',
    RS = <any> 'RS',
    SC = <any> 'SC',
    SL = <any> 'SL',
    SG = <any> 'SG',
    SX = <any> 'SX',
    SK = <any> 'SK',
    SI = <any> 'SI',
    SB = <any> 'SB',
    SO = <any> 'SO',
    ZA = <any> 'ZA',
    GS = <any> 'GS',
    SS = <any> 'SS',
    ES = <any> 'ES',
    LK = <any> 'LK',
    SD = <any> 'SD',
    SR = <any> 'SR',
    SJ = <any> 'SJ',
    SZ = <any> 'SZ',
    SE = <any> 'SE',
    CH = <any> 'CH',
    SY = <any> 'SY',
    TW = <any> 'TW',
    TJ = <any> 'TJ',
    TZ = <any> 'TZ',
    TH = <any> 'TH',
    TL = <any> 'TL',
    TG = <any> 'TG',
    TK = <any> 'TK',
    TO = <any> 'TO',
    TT = <any> 'TT',
    TN = <any> 'TN',
    TR = <any> 'TR',
    TM = <any> 'TM',
    TC = <any> 'TC',
    TV = <any> 'TV',
    UG = <any> 'UG',
    UA = <any> 'UA',
    AE = <any> 'AE',
    GB = <any> 'GB',
    US = <any> 'US',
    UM = <any> 'UM',
    UY = <any> 'UY',
    UZ = <any> 'UZ',
    VU = <any> 'VU',
    VE = <any> 'VE',
    VN = <any> 'VN',
    VG = <any> 'VG',
    VI = <any> 'VI',
    WF = <any> 'WF',
    EH = <any> 'EH',
    YE = <any> 'YE',
    ZM = <any> 'ZM',
    ZW = <any> 'ZW'
}
/**
 * 
 * @export
 * @interface CreateGroupPaymentRequest
 */
export interface CreateGroupPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    idempotencyKey: string;
    /**
     * Can either be a customerId or customer object
     * @type {string | CustomerCreationParams}
     * @memberof CreateGroupPaymentRequest
     */
    customer: string | CustomerCreationParams;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    orderId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    checkoutId?: string;
    /**
     * 
     * @type {SplitType}
     * @memberof CreateGroupPaymentRequest
     */
    splitType?: SplitType;
    /**
     * 
     * @type {number}
     * @memberof CreateGroupPaymentRequest
     */
    splitAllocation?: number;
    /**
     * 
     * @type {CustomAllocations}
     * @memberof CreateGroupPaymentRequest
     */
    customAllocation?: CustomAllocations;
    /**
     * 
     * @type {ItemAllocations}
     * @memberof CreateGroupPaymentRequest
     */
    itemAllocation?: ItemAllocations;
    /**
     * 
     * @type {Money}
     * @memberof CreateGroupPaymentRequest
     */
    amountMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof CreateGroupPaymentRequest
     */
    tipMoney?: Money;
    /**
     * 
     * @type {Date}
     * @memberof CreateGroupPaymentRequest
     */
    expirationDate?: Date;
    /**
     * 
     * @type {Address}
     * @memberof CreateGroupPaymentRequest
     */
    shippingAddress?: Address;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    statementDescriptionIdentifier?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    referenceId?: string;
}
/**
 * 
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    idempotencyKey: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    orderId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    paymentToken: string;
    /**
     * 
     * @type {Money}
     * @memberof CreatePaymentRequest
     */
    amountMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof CreatePaymentRequest
     */
    tipMoney?: Money;
    /**
     * 
     * @type {Money}
     * @memberof CreatePaymentRequest
     */
    sellerFee?: Money;
    /**
     * 
     * @type {Address}
     * @memberof CreatePaymentRequest
     */
    billingAddress?: Address;
    /**
     * 
     * @type {Address}
     * @memberof CreatePaymentRequest
     */
    shippingAddress?: Address;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePaymentRequest
     */
    autocomplete?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof CreatePaymentRequest
     */
    expirationDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    verificationToken?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    statementDescriptionIdentifier?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    referenceId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Currency {
    AED = <any> 'AED',
    AFN = <any> 'AFN',
    ALL = <any> 'ALL',
    AMD = <any> 'AMD',
    ANG = <any> 'ANG',
    AOA = <any> 'AOA',
    ARS = <any> 'ARS',
    AUD = <any> 'AUD',
    AWG = <any> 'AWG',
    AZN = <any> 'AZN',
    BAM = <any> 'BAM',
    BBD = <any> 'BBD',
    BDT = <any> 'BDT',
    BGN = <any> 'BGN',
    BHD = <any> 'BHD',
    BIF = <any> 'BIF',
    BMD = <any> 'BMD',
    BND = <any> 'BND',
    BOB = <any> 'BOB',
    BRL = <any> 'BRL',
    BSD = <any> 'BSD',
    BTN = <any> 'BTN',
    BWP = <any> 'BWP',
    BYN = <any> 'BYN',
    BZD = <any> 'BZD',
    CAD = <any> 'CAD',
    CDF = <any> 'CDF',
    CHF = <any> 'CHF',
    CLP = <any> 'CLP',
    CNY = <any> 'CNY',
    COP = <any> 'COP',
    CRC = <any> 'CRC',
    CUC = <any> 'CUC',
    CUP = <any> 'CUP',
    CVE = <any> 'CVE',
    CZK = <any> 'CZK',
    DJF = <any> 'DJF',
    DKK = <any> 'DKK',
    DOP = <any> 'DOP',
    DZD = <any> 'DZD',
    EGP = <any> 'EGP',
    ERN = <any> 'ERN',
    ETB = <any> 'ETB',
    EUR = <any> 'EUR',
    FJD = <any> 'FJD',
    FKP = <any> 'FKP',
    GBP = <any> 'GBP',
    GEL = <any> 'GEL',
    GHS = <any> 'GHS',
    GIP = <any> 'GIP',
    GMD = <any> 'GMD',
    GNF = <any> 'GNF',
    GTQ = <any> 'GTQ',
    GYD = <any> 'GYD',
    HKD = <any> 'HKD',
    HNL = <any> 'HNL',
    HRK = <any> 'HRK',
    HTG = <any> 'HTG',
    HUF = <any> 'HUF',
    IDR = <any> 'IDR',
    ILS = <any> 'ILS',
    INR = <any> 'INR',
    IQD = <any> 'IQD',
    IRR = <any> 'IRR',
    ISK = <any> 'ISK',
    JMD = <any> 'JMD',
    JOD = <any> 'JOD',
    JPY = <any> 'JPY',
    KES = <any> 'KES',
    KGS = <any> 'KGS',
    KHR = <any> 'KHR',
    KMF = <any> 'KMF',
    KPW = <any> 'KPW',
    KRW = <any> 'KRW',
    KWD = <any> 'KWD',
    KYD = <any> 'KYD',
    KZT = <any> 'KZT',
    LAK = <any> 'LAK',
    LBP = <any> 'LBP',
    LKR = <any> 'LKR',
    LRD = <any> 'LRD',
    LSL = <any> 'LSL',
    LYD = <any> 'LYD',
    MAD = <any> 'MAD',
    MDL = <any> 'MDL',
    MGA = <any> 'MGA',
    MKD = <any> 'MKD',
    MMK = <any> 'MMK',
    MNT = <any> 'MNT',
    MOP = <any> 'MOP',
    MRU = <any> 'MRU',
    MUR = <any> 'MUR',
    MVR = <any> 'MVR',
    MWK = <any> 'MWK',
    MXN = <any> 'MXN',
    MYR = <any> 'MYR',
    MZN = <any> 'MZN',
    NAD = <any> 'NAD',
    NGN = <any> 'NGN',
    NIO = <any> 'NIO',
    NOK = <any> 'NOK',
    NPR = <any> 'NPR',
    NZD = <any> 'NZD',
    OMR = <any> 'OMR',
    PAB = <any> 'PAB',
    PEN = <any> 'PEN',
    PGK = <any> 'PGK',
    PHP = <any> 'PHP',
    PKR = <any> 'PKR',
    PLN = <any> 'PLN',
    PYG = <any> 'PYG',
    QAR = <any> 'QAR',
    RON = <any> 'RON',
    RSD = <any> 'RSD',
    RUB = <any> 'RUB',
    RWF = <any> 'RWF',
    SAR = <any> 'SAR',
    SBD = <any> 'SBD',
    SCR = <any> 'SCR',
    SDG = <any> 'SDG',
    SEK = <any> 'SEK',
    SGD = <any> 'SGD',
    SHP = <any> 'SHP',
    SLL = <any> 'SLL',
    SOS = <any> 'SOS',
    SRD = <any> 'SRD',
    SSP = <any> 'SSP',
    STN = <any> 'STN',
    SVC = <any> 'SVC',
    SYP = <any> 'SYP',
    SZL = <any> 'SZL',
    THB = <any> 'THB',
    TJS = <any> 'TJS',
    TMT = <any> 'TMT',
    TND = <any> 'TND',
    TOP = <any> 'TOP',
    TRY = <any> 'TRY',
    TTD = <any> 'TTD',
    TWD = <any> 'TWD',
    TZS = <any> 'TZS',
    UAH = <any> 'UAH',
    UGX = <any> 'UGX',
    USD = <any> 'USD',
    UYU = <any> 'UYU',
    UZS = <any> 'UZS',
    VES = <any> 'VES',
    VND = <any> 'VND',
    VUV = <any> 'VUV',
    WST = <any> 'WST',
    XAF = <any> 'XAF',
    XCD = <any> 'XCD',
    XOF = <any> 'XOF',
    XPF = <any> 'XPF',
    YER = <any> 'YER',
    ZAR = <any> 'ZAR',
    ZMW = <any> 'ZMW',
    ZWL = <any> 'ZWL'
}
/**
 * 
 * @export
 * @interface CustomAllocations
 */
export interface CustomAllocations extends null<String, Money> {
    [key: string]: Money;

}
/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    lastName?: string;
    /**
     * 
     * @type {EmailAddress}
     * @memberof Customer
     */
    email: EmailAddress;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    phoneNumber?: string;
    /**
     * 
     * @type {Url}
     * @memberof Customer
     */
    imageUrl?: Url;
    /**
     * 
     * @type {Address}
     * @memberof Customer
     */
    address?: Address;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    language?: string;
    /**
     * 
     * @type {Date}
     * @memberof Customer
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Customer
     */
    updatedAt?: Date;
}
/**
 * 
 * @export
 * @interface CustomerCreationParams
 */
export interface CustomerCreationParams {
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    lastName?: string;
    /**
     * 
     * @type {EmailAddress}
     * @memberof CustomerCreationParams
     */
    email: EmailAddress;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    language?: string;
}
/**
 * 
 * @export
 * @interface DeviceDetails
 */
export interface DeviceDetails {
    /**
     * 
     * @type {string}
     * @memberof DeviceDetails
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDetails
     */
    deviceInstallationId?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDetails
     */
    deviceName?: string;
}
/**
 * 
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    code: string;
    /**
     * 
     * @type {Money}
     * @memberof Discount
     */
    amountMoney: Money;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DisplayType {
    Page = <any> 'page',
    Popup = <any> 'popup',
    Touch = <any> 'touch',
    Wap = <any> 'wap'
}
/**
 * 
 * @export
 * @interface Dispute
 */
export interface Dispute {
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    paymentId: string;
    /**
     * 
     * @type {Money}
     * @memberof Dispute
     */
    amountMoney: Money;
    /**
     * 
     * @type {DisputeReason}
     * @memberof Dispute
     */
    reason: DisputeReason;
    /**
     * 
     * @type {DisputeStatus}
     * @memberof Dispute
     */
    status: DisputeStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof Dispute
     */
    evidenceIds?: Array<string>;
    /**
     * 
     * @type {CardBrand}
     * @memberof Dispute
     */
    cardBrand?: CardBrand;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    brandDisputeId?: string;
    /**
     * 
     * @type {Date}
     * @memberof Dispute
     */
    dueAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Dispute
     */
    reportedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    locationId?: string;
    /**
     * 
     * @type {Date}
     * @memberof Dispute
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Dispute
     */
    updatedAt?: Date;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    version?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DisputeReason {
    AMOUNTDIFFERS = <any> 'AMOUNT_DIFFERS',
    CANCELLED = <any> 'CANCELLED',
    DUPLICATE = <any> 'DUPLICATE',
    NOKNOWLEDGE = <any> 'NO_KNOWLEDGE',
    NOTASDESCRIBED = <any> 'NOT_AS_DESCRIBED',
    NOTRECEIVED = <any> 'NOT_RECEIVED',
    PAIDBYOTHERMEANS = <any> 'PAID_BY_OTHER_MEANS',
    CUSTOMERREQUESTSCREDIT = <any> 'CUSTOMER_REQUESTS_CREDIT',
    EMVLIABILITYSHIFT = <any> 'EMV_LIABILITY_SHIFT'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DisputeStatus {
    UNKNOWN = <any> 'UNKNOWN',
    INQUIRYEVIDENCEREQUIRED = <any> 'INQUIRY_EVIDENCE_REQUIRED',
    INQUIRYPROCESSING = <any> 'INQUIRY_PROCESSING',
    INQUIRYCLOSED = <any> 'INQUIRY_CLOSED',
    EVIDENCEREQUIRED = <any> 'EVIDENCE_REQUIRED',
    PROCESSING = <any> 'PROCESSING',
    WON = <any> 'WON',
    LOST = <any> 'LOST',
    ACCEPTED = <any> 'ACCEPTED',
    WAITINGTHIRDPARTY = <any> 'WAITING_THIRD_PARTY'
}
/**
 * 
 * @export
 * @interface ETSITokenResponse
 */
export interface ETSITokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ETSITokenResponse
     */
    nfvToken?: string;
}
/**
 * 
 * @export
 * @interface Email
 */
export interface Email {
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    id: string;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof Email
     */
    to: Array<EmailAddress>;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof Email
     */
    cc?: Array<EmailAddress>;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof Email
     */
    bcc?: Array<EmailAddress>;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    subject: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    html?: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    text?: string;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof Email
     */
    attachment?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    referenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    templateName?: string;
    /**
     * 
     * @type {ModelObject}
     * @memberof Email
     */
    variables?: ModelObject;
    /**
     * 
     * @type {MetaData}
     * @memberof Email
     */
    metaData?: MetaData;
}
/**
 * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
 * @export
 */
export type EmailAddress = string
/**
 * 
 * @export
 * @interface EmailCreationParams
 */
export interface EmailCreationParams {
}
/**
 * 
 * @export
 * @interface ExternalPaymentDetails
 */
export interface ExternalPaymentDetails {
    /**
     * 
     * @type {string}
     * @memberof ExternalPaymentDetails
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalPaymentDetails
     */
    source: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalPaymentDetails
     */
    sourceId?: string;
    /**
     * 
     * @type {Money}
     * @memberof ExternalPaymentDetails
     */
    sourceFeeMoney?: Money;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    ownerId: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Group
     */
    memberIds: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name?: string;
    /**
     * 
     * @type {Date}
     * @memberof Group
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Group
     */
    updatedAt?: Date;
}
/**
 * 
 * @export
 * @interface GroupCreationParams
 */
export interface GroupCreationParams {
    /**
     * 
     * @type {string}
     * @memberof GroupCreationParams
     */
    ownerId: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupCreationParams
     */
    memberIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GroupCreationParams
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface GroupPaymentIdCancelBody
 */
export interface GroupPaymentIdCancelBody {
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentIdCancelBody
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface GroupPaymentRecord
 */
export interface GroupPaymentRecord {
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    ownerId: string;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof GroupPaymentRecord
     */
    status: PaymentStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupPaymentRecord
     */
    memberIds: Array<string>;
    /**
     * 
     * @type {MemberPayments}
     * @memberof GroupPaymentRecord
     */
    memberPayments: MemberPayments;
    /**
     * 
     * @type {ModelInteger}
     * @memberof GroupPaymentRecord
     */
    splitAllocation?: ModelInteger;
    /**
     * 
     * @type {SplitType}
     * @memberof GroupPaymentRecord
     */
    splitType: SplitType;
    /**
     * 
     * @type {CustomAllocations}
     * @memberof GroupPaymentRecord
     */
    customAllocation?: CustomAllocations;
    /**
     * 
     * @type {ItemAllocations}
     * @memberof GroupPaymentRecord
     */
    itemAllocation?: ItemAllocations;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    orderId?: string;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    totalMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    amountMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    tipMoney?: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    approvedMoney?: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    refundedMoney?: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    groupAppFee?: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    totalAppFees?: Money;
    /**
     * 
     * @type {Array<ProcessingFee>}
     * @memberof GroupPaymentRecord
     */
    processingFees?: Array<ProcessingFee>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupPaymentRecord
     */
    refundIds?: Array<string>;
    /**
     * 
     * @type {Address}
     * @memberof GroupPaymentRecord
     */
    shippingAddress?: Address;
    /**
     * If the total payment is not made up by the group members by this date then the transaction will be cancelled. Default 7 days.
     * @type {Date}
     * @memberof GroupPaymentRecord
     */
    expirationDate?: Date;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof GroupPaymentRecord
     */
    riskEvaluation?: RiskEvaluation;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    statementDescriptionIdentifier?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    referenceId?: string;
    /**
     * 
     * @type {MetaData}
     * @memberof GroupPaymentRecord
     */
    metaData?: MetaData;
    /**
     * The inviteUrl is only generated when the group payment is fully hosted by hands in
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    url?: string;
    /**
     * The message is shown to everyone in the group when fully hosted by hands in
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    message?: string;
    /**
     * 
     * @type {Date}
     * @memberof GroupPaymentRecord
     */
    createdAt: Date;
    /**
     * 
     * @type {Date}
     * @memberof GroupPaymentRecord
     */
    updatedAt: Date;
    /**
     * 
     * @type {number}
     * @memberof GroupPaymentRecord
     */
    version: number;
}
/**
 * 
 * @export
 * @interface GroupPaymentRefundRequest
 */
export interface GroupPaymentRefundRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRefundRequest
     */
    idempotencyKey: string;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRefundRequest
     */
    appFee?: Money;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRefundRequest
     */
    reason?: string;
}
/**
 * 
 * @export
 * @interface GroupPaymentUpdateParams
 */
export interface GroupPaymentUpdateParams extends PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_ {
    /**
     * 
     * @type {boolean}
     * @memberof GroupPaymentUpdateParams
     */
    emailNotification?: boolean;
}
/**
 * 
 * @export
 * @interface HtmlEmailCreationParams
 */
export interface HtmlEmailCreationParams {
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof HtmlEmailCreationParams
     */
    to: Array<EmailAddress>;
    /**
     * 
     * @type {string}
     * @memberof HtmlEmailCreationParams
     */
    subject: string;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof HtmlEmailCreationParams
     */
    cc?: Array<EmailAddress>;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof HtmlEmailCreationParams
     */
    bcc?: Array<EmailAddress>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof HtmlEmailCreationParams
     */
    attachment?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof HtmlEmailCreationParams
     */
    html: string;
    /**
     * 
     * @type {string}
     * @memberof HtmlEmailCreationParams
     */
    text?: string;
    /**
     * 
     * @type {string}
     * @memberof HtmlEmailCreationParams
     */
    templateName?: string;
    /**
     * 
     * @type {ModelObject}
     * @memberof HtmlEmailCreationParams
     */
    variables?: ModelObject;
}
/**
 * 
 * @export
 * @interface IESGTokenResponse
 */
export interface IESGTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof IESGTokenResponse
     */
    issuedTokenType?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum IETFResponseType {
    Code = <any> 'code',
    Token = <any> 'token'
}
/**
 * 
 * @export
 * @interface IETFTokenResponse
 */
export interface IETFTokenResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof IETFTokenResponse
     */
    scope?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    tokenType?: string;
    /**
     * 
     * @type {ModelInteger}
     * @memberof IETFTokenResponse
     */
    expiresIn?: ModelInteger;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    refreshToken?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    aceProfile?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    rsCnf?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    cnf?: string;
}
/**
 * 
 * @export
 * @interface InvitedMembers
 */
export interface InvitedMembers extends null<String, any> {
    [key: string]: any;

}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    name: string;
    /**
     * 
     * @type {Money}
     * @memberof Item
     */
    amountMoney: Money;
    /**
     * 
     * @type {Attributes}
     * @memberof Item
     */
    attributes?: Attributes;
    /**
     * 
     * @type {ItemOrderDetails}
     * @memberof Item
     */
    orderDetails?: ItemOrderDetails;
    /**
     * 
     * @type {ItemInventoryDetails}
     * @memberof Item
     */
    inventoryDetails?: ItemInventoryDetails;
    /**
     * Max 10 images per item. Default image is the first in array.
     * @type {Array<Url>}
     * @memberof Item
     */
    imageUrls?: Array<Url>;
    /**
     * 300 word description of the item.
     * @type {string}
     * @memberof Item
     */
    description?: string;
    /**
     * referenceId for merchant to use for internal system
     * @type {string}
     * @memberof Item
     */
    referenceId?: string;
    /**
     * 
     * @type {MetaData}
     * @memberof Item
     */
    metaData?: MetaData;
    /**
     * 
     * @type {Date}
     * @memberof Item
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Item
     */
    updatedAt?: Date;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface ItemAllocations
 */
export interface ItemAllocations extends null<String, Array> {
    [key: string]: Array<string>;

}
/**
 * 
 * @export
 * @interface ItemCreationParams
 */
export interface ItemCreationParams {
    /**
     * 
     * @type {string}
     * @memberof ItemCreationParams
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCreationParams
     */
    name: string;
    /**
     * 
     * @type {Money}
     * @memberof ItemCreationParams
     */
    amountMoney: Money;
    /**
     * 
     * @type {Attributes}
     * @memberof ItemCreationParams
     */
    attributes?: Attributes;
    /**
     * Max of 10 images per item. The first will always be the default.
     * @type {Array<Url>}
     * @memberof ItemCreationParams
     */
    imageUrls?: Array<Url>;
    /**
     * 
     * @type {string}
     * @memberof ItemCreationParams
     */
    description?: string;
    /**
     * 
     * @type {ItemCreationParamsOrderDetails}
     * @memberof ItemCreationParams
     */
    orderDetails?: ItemCreationParamsOrderDetails;
    /**
     * 
     * @type {ItemCreationParamsInventoryDetails}
     * @memberof ItemCreationParams
     */
    inventoryDetails?: ItemCreationParamsInventoryDetails;
    /**
     * 
     * @type {MetaData}
     * @memberof ItemCreationParams
     */
    metaData?: MetaData;
    /**
     * 
     * @type {string}
     * @memberof ItemCreationParams
     */
    referenceId?: string;
}
/**
 * 
 * @export
 * @interface ItemCreationParamsInventoryDetails
 */
export interface ItemCreationParamsInventoryDetails {
    /**
     * 
     * @type {number}
     * @memberof ItemCreationParamsInventoryDetails
     */
    unitsAvailable?: number;
    /**
     * This will be shown on your Hands In catalogue
     * @type {string}
     * @memberof ItemCreationParamsInventoryDetails
     */
    unitType?: string;
}
/**
 * 
 * @export
 * @interface ItemCreationParamsOrderDetails
 */
export interface ItemCreationParamsOrderDetails {
    /**
     * This will default to the units available if not provided
     * @type {number}
     * @memberof ItemCreationParamsOrderDetails
     */
    maxUnitsPerOrder?: number;
    /**
     * This will default to 0 if not provided
     * @type {number}
     * @memberof ItemCreationParamsOrderDetails
     */
    minUnitsPerOrder?: number;
    /**
     * Set to true if the item can be shipped
     * @type {boolean}
     * @memberof ItemCreationParamsOrderDetails
     */
    isShippable?: boolean;
}
/**
 * 
 * @export
 * @interface ItemInventoryDetails
 */
export interface ItemInventoryDetails {
    /**
     * 
     * @type {ModelInteger}
     * @memberof ItemInventoryDetails
     */
    unitsAvailable?: ModelInteger;
    /**
     * This will be shown on your Hands In and checkout pages
     * @type {string}
     * @memberof ItemInventoryDetails
     */
    unitType?: string;
}
/**
 * 
 * @export
 * @interface ItemListParams
 */
export interface ItemListParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemListParams
     */
    itemIds: Array<string>;
}
/**
 * Details used by the ordering service to determine limitations for orders
 * @export
 * @interface ItemOrderDetails
 */
export interface ItemOrderDetails {
    /**
     * Set to true if item is must be shipped out
     * @type {boolean}
     * @memberof ItemOrderDetails
     */
    isShippable?: boolean;
}
/**
 * 
 * @export
 * @interface ItemUpdateParams
 */
export interface ItemUpdateParams {
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateParams
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateParams
     */
    name: string;
    /**
     * 
     * @type {Money}
     * @memberof ItemUpdateParams
     */
    amountMoney: Money;
    /**
     * 
     * @type {Attributes}
     * @memberof ItemUpdateParams
     */
    attributes?: Attributes;
    /**
     * Max of 10 images per item. The first will always be the default.
     * @type {Array<Url>}
     * @memberof ItemUpdateParams
     */
    imageUrls?: Array<Url>;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateParams
     */
    description?: string;
    /**
     * 
     * @type {ItemCreationParamsOrderDetails}
     * @memberof ItemUpdateParams
     */
    orderDetails?: ItemCreationParamsOrderDetails;
    /**
     * 
     * @type {ItemCreationParamsInventoryDetails}
     * @memberof ItemUpdateParams
     */
    inventoryDetails?: ItemCreationParamsInventoryDetails;
    /**
     * 
     * @type {MetaData}
     * @memberof ItemUpdateParams
     */
    metaData?: MetaData;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateParams
     */
    referenceId?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemUpdateParams
     */
    atomicUnitChange?: number;
}
/**
 * 
 * @export
 * @interface JoinGroupPaymentRequest
 */
export interface JoinGroupPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof JoinGroupPaymentRequest
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface KickGroupPaymentRequest
 */
export interface KickGroupPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof KickGroupPaymentRequest
     */
    ownerId: string;
    /**
     * 
     * @type {string}
     * @memberof KickGroupPaymentRequest
     */
    kickId: string;
}
/**
 * 
 * @export
 * @interface LeaveGroupPaymentRequest
 */
export interface LeaveGroupPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof LeaveGroupPaymentRequest
     */
    customerId: string;
    /**
     * 
     * @type {string}
     * @memberof LeaveGroupPaymentRequest
     */
    newOwnerId?: string;
}
/**
 * 
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * 
     * @type {PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_}
     * @memberof LineItem
     */
    item: PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_;
    /**
     * 
     * @type {ModelInteger}
     * @memberof LineItem
     */
    quantity: ModelInteger;
    /**
     * 
     * @type {Money}
     * @memberof LineItem
     */
    taxAmount?: Money;
    /**
     * 
     * @type {Array<Tax>}
     * @memberof LineItem
     */
    taxes?: Array<Tax>;
    /**
     * 
     * @type {Money}
     * @memberof LineItem
     */
    subtotalAmount: Money;
    /**
     * 
     * @type {Money}
     * @memberof LineItem
     */
    totalAmount: Money;
}
/**
 * 
 * @export
 * @interface LineItemCreationParam
 */
export interface LineItemCreationParam {
    /**
     * Item can be created inline if neccessary
     * @type {string | ItemCreationParams}
     * @memberof LineItemCreationParam
     */
    item: string | ItemCreationParams;
    /**
     * 
     * @type {ModelInteger}
     * @memberof LineItemCreationParam
     */
    quantity: ModelInteger;
}
/**
 * 
 * @export
 * @interface LoginParams
 */
export interface LoginParams {
    /**
     * 
     * @type {EmailAddress}
     * @memberof LoginParams
     */
    email: EmailAddress;
    /**
     * 
     * @type {Password}
     * @memberof LoginParams
     */
    password: Password;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoginParams
     */
    scopes?: Array<string>;
}
/**
 * 
 * @export
 * @interface MemberPayments
 */
export interface MemberPayments extends null<String, string> {
    [key: string]: string;

}
/**
 * 
 * @export
 * @interface Members
 */
export interface Members extends null<String, any> {
    [key: string]: any;

}
/**
 * 
 * @export
 * @interface MerchantApiKeySummary
 */
export interface MerchantApiKeySummary {
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    ownerId: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    merchantToken: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    description?: string;
    /**
     * 
     * @type {Date}
     * @memberof MerchantApiKeySummary
     */
    createdAt?: Date;
}
/**
 * 
 * @export
 * @interface MerchantContactDetails
 */
export interface MerchantContactDetails {
    /**
     * 
     * @type {EmailAddress}
     * @memberof MerchantContactDetails
     */
    email: EmailAddress;
    /**
     * 
     * @type {string}
     * @memberof MerchantContactDetails
     */
    companyNumber?: string;
    /**
     * 
     * @type {Address}
     * @memberof MerchantContactDetails
     */
    address?: Address;
    /**
     * 
     * @type {string}
     * @memberof MerchantContactDetails
     */
    phoneNumber?: string;
}
/**
 * 
 * @export
 * @interface MerchantCreationParams
 */
export interface MerchantCreationParams {
}
/**
 * 
 * @export
 * @interface MerchantDTO
 */
export interface MerchantDTO {
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    logoUrl?: string;
    /**
     * 
     * @type {MerchantContactDetails}
     * @memberof MerchantDTO
     */
    contactDetails: MerchantContactDetails;
    /**
     * 
     * @type {Array<MerchantApiKeySummary>}
     * @memberof MerchantDTO
     */
    liveKeys: Array<MerchantApiKeySummary>;
    /**
     * 
     * @type {Array<MerchantApiKeySummary>}
     * @memberof MerchantDTO
     */
    testKeys: Array<MerchantApiKeySummary>;
    /**
     * 
     * @type {Members}
     * @memberof MerchantDTO
     */
    team: Members;
    /**
     * 
     * @type {InvitedMembers}
     * @memberof MerchantDTO
     */
    invites?: InvitedMembers;
    /**
     * 
     * @type {Currency}
     * @memberof MerchantDTO
     */
    defaultCurrency: Currency;
}
/**
 * 
 * @export
 * @interface MerchantIdInviteBody
 */
export interface MerchantIdInviteBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof MerchantIdInviteBody
     */
    scopes?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof MerchantIdInviteBody
     */
    resend?: boolean;
}
/**
 * 
 * @export
 * @interface MetaData
 */
export interface MetaData extends null<String, string> {
    [key: string]: string;

}
/**
 * 
 * @export
 * @interface ModelBoolean
 */
export interface ModelBoolean {
}
/**
 * 
 * @export
 */
export type ModelInteger = number
/**
 * 
 * @export
 * @interface Money
 */
export interface Money {
    /**
     * 
     * @type {ModelInteger}
     * @memberof Money
     */
    amount: ModelInteger;
    /**
     * 
     * @type {Currency}
     * @memberof Money
     */
    currency: Currency;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OAuthGrantType {
    AuthorizationCode = <any> 'authorization_code',
    RefreshToken = <any> 'refresh_token',
    ClientCredentials = <any> 'client_credentials'
}
/**
 * 
 * @export
 * @interface OAuthResponseType
 */
export interface OAuthResponseType {
}
/**
 * 
 * @export
 * @interface OAuthTokenResponse
 */
export interface OAuthTokenResponse {
}
/**
 * 
 * @export
 * @interface OmitClientVerifiedSigOrTrustedSig_
 */
export interface OmitClientVerifiedSigOrTrustedSig_ {
}
/**
 * 
 * @export
 * @interface OpenIDTokenResponse
 */
export interface OpenIDTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof OpenIDTokenResponse
     */
    idToken?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIDTokenResponse
     */
    sessionState?: string;
}
/**
 * 
 * @export
 * @interface OpenIdAddress
 */
export interface OpenIdAddress {
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    postalCode: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    region: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    locality: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    streetAddress: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdAddress
     */
    formatted: string;
}
/**
 * 
 * @export
 * @interface OpenIdIdTokenData
 */
export interface OpenIdIdTokenData {
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    sub: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    givenName?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    familyName?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    preferredUsername?: string;
    /**
     * 
     * @type {Url}
     * @memberof OpenIdIdTokenData
     */
    picture?: Url;
    /**
     * 
     * @type {Url}
     * @memberof OpenIdIdTokenData
     */
    profile?: Url;
    /**
     * 
     * @type {Url}
     * @memberof OpenIdIdTokenData
     */
    website?: Url;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    gender?: OpenIdIdTokenData.GenderEnum;
    /**
     * 
     * @type {Date}
     * @memberof OpenIdIdTokenData
     */
    birthdate?: Date;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    zoneinfo?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    locale?: string;
    /**
     * 
     * @type {Date}
     * @memberof OpenIdIdTokenData
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    phoneNumber?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenIdIdTokenData
     */
    phoneNumberVerified?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenIdIdTokenData
     */
    emailVerified?: boolean;
    /**
     * 
     * @type {OpenIdAddress}
     * @memberof OpenIdIdTokenData
     */
    address?: OpenIdAddress;
    /**
     * 
     * @type {Date}
     * @memberof OpenIdIdTokenData
     */
    authTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    nonce?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    acr?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    amr?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdIdTokenData
     */
    azp?: string;
}

/**
 * @export
 * @namespace OpenIdIdTokenData
 */
export namespace OpenIdIdTokenData {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        Female = <any> 'female',
        Male = <any> 'male'
    }
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OpenIdResponseType {
    IdToken = <any> 'id_token',
    IdTokenToken = <any> 'id_token token',
    CodeIdTokenToken = <any> 'code id_token token',
    CodeIdToken = <any> 'code id_token',
    CodeToken = <any> 'code token',
    None = <any> 'none'
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    id: string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof Order
     */
    status: OrderStatus;
    /**
     * 
     * @type {Array<LineItem>}
     * @memberof Order
     */
    lineItems: Array<LineItem>;
    /**
     * 
     * @type {Money}
     * @memberof Order
     */
    totalMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof Order
     */
    subtotalMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof Order
     */
    discountMoney?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Order
     */
    tipMoney?: Money;
    /**
     * 
     * @type {Array<Tax>}
     * @memberof Order
     */
    taxes?: Array<Tax>;
    /**
     * 
     * @type {Array<Discount>}
     * @memberof Order
     */
    discounts?: Array<Discount>;
    /**
     * 
     * @type {Address}
     * @memberof Order
     */
    shippingAddress?: Address;
    /**
     * 
     * @type {MetaData}
     * @memberof Order
     */
    metaData?: MetaData;
    /**
     * 
     * @type {Date}
     * @memberof Order
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Order
     */
    updatedAt?: Date;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface OrderCreationParams
 */
export interface OrderCreationParams {
    /**
     * 
     * @type {Array<LineItemCreationParam>}
     * @memberof OrderCreationParams
     */
    lineItemParams: Array<LineItemCreationParam>;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrderCreationParams
     */
    discountCodes?: Array<string>;
    /**
     * Customer who is paying for the order
     * @type {string | CustomerCreationParams}
     * @memberof OrderCreationParams
     */
    customer?: string | CustomerCreationParams;
    /**
     * 
     * @type {Address}
     * @memberof OrderCreationParams
     */
    shippingAddress?: Address;
    /**
     * 
     * @type {MetaData}
     * @memberof OrderCreationParams
     */
    metaData?: MetaData;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderStatus {
    PENDING = <any> 'PENDING',
    COMPLETED = <any> 'COMPLETED',
    CANCELLED = <any> 'CANCELLED',
    FULFILLED = <any> 'FULFILLED',
    RETURNED = <any> 'RETURNED'
}
/**
 * 
 * @export
 * @interface OrderUpdateParams
 */
export interface OrderUpdateParams {
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
 */
export interface PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_ {
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    orderId?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    checkoutId?: string;
    /**
     * 
     * @type {SplitType}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    splitType?: SplitType;
    /**
     * 
     * @type {ModelInteger}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    splitAllocation?: ModelInteger;
    /**
     * 
     * @type {CustomAllocations}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    customAllocation?: CustomAllocations;
    /**
     * 
     * @type {ItemAllocations}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    itemAllocation?: ItemAllocations;
    /**
     * 
     * @type {Money}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    amountMoney?: Money;
    /**
     * 
     * @type {Date}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    expirationDate?: Date;
    /**
     * 
     * @type {Address}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    shippingAddress?: Address;
    /**
     * If this is set to true, the group payment will be completed as soon as the total amount is made up  Defaults to true.
     * @type {boolean}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    autocomplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    statementDescriptionIdentifier?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialOmitGroupPaymentCreationParamsCustomerOrIdempotencyKey_
     */
    referenceId?: string;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialOrderCreationParams_
 */
export interface PartialOrderCreationParams_ {
    /**
     * 
     * @type {Array<LineItemCreationParam>}
     * @memberof PartialOrderCreationParams_
     */
    lineItemParams?: Array<LineItemCreationParam>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PartialOrderCreationParams_
     */
    discountCodes?: Array<string>;
    /**
     * Customer who is paying for the order
     * @type {string | CustomerCreationParams}
     * @memberof PartialOrderCreationParams_
     */
    customer?: string | CustomerCreationParams;
    /**
     * 
     * @type {Address}
     * @memberof PartialOrderCreationParams_
     */
    shippingAddress?: Address;
    /**
     * 
     * @type {MetaData}
     * @memberof PartialOrderCreationParams_
     */
    metaData?: MetaData;
}
/**
 * Password
 * @export
 */
export type Password = string
/**
 * 
 * @export
 * @interface PasswordResetParams
 */
export interface PasswordResetParams {
    /**
     * 
     * @type {EmailAddress}
     * @memberof PasswordResetParams
     */
    email: EmailAddress;
    /**
     * 
     * @type {Password}
     * @memberof PasswordResetParams
     */
    password: Password;
    /**
     * 
     * @type {Password}
     * @memberof PasswordResetParams
     */
    confirmPassword: Password;
}
/**
 * 
 * @export
 * @interface PayIntoGroupPaymentRequest
 */
export interface PayIntoGroupPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    idempotencyKey: string;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    paymentToken: string;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    customerId: string;
    /**
     * 
     * @type {Money}
     * @memberof PayIntoGroupPaymentRequest
     */
    tipMoney?: Money;
    /**
     * 
     * @type {Money}
     * @memberof PayIntoGroupPaymentRequest
     */
    appFee?: Money;
    /**
     * 
     * @type {Address}
     * @memberof PayIntoGroupPaymentRequest
     */
    billingAddress?: Address;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    verificationToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    statementDescriptionIdentifier?: string;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    referenceId?: string;
}
/**
 * 
 * @export
 * @interface PaymentError
 */
export interface PaymentError {
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    category: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    detail?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    field?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PaymentMethod {
    CARD = <any> 'CARD',
    BANKACCOUNT = <any> 'BANK_ACCOUNT',
    CASH = <any> 'CASH',
    EXTERNAL = <any> 'EXTERNAL'
}
/**
 * 
 * @export
 * @interface PaymentRecord
 */
export interface PaymentRecord {
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    customerId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    orderId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    groupPaymentId?: string;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    totalMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    amountMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    tipMoney?: Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    approvedMoney?: Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    refundedMoney?: Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    appFee?: Money;
    /**
     * 
     * @type {Array<ProcessingFee>}
     * @memberof PaymentRecord
     */
    processingFees?: Array<ProcessingFee>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentRecord
     */
    refundIds?: Array<string>;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof PaymentRecord
     */
    status: PaymentStatus;
    /**
     * 
     * @type {Date}
     * @memberof PaymentRecord
     */
    expirationDate?: Date;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentRecord
     */
    paymentMethod: PaymentMethod;
    /**
     * 
     * @type {CardPaymentDetails}
     * @memberof PaymentRecord
     */
    cardDetails?: CardPaymentDetails;
    /**
     * 
     * @type {BankAccountPaymentDetails}
     * @memberof PaymentRecord
     */
    bankAccountDetails?: BankAccountPaymentDetails;
    /**
     * 
     * @type {CashPaymentDetails}
     * @memberof PaymentRecord
     */
    cashDetails?: CashPaymentDetails;
    /**
     * 
     * @type {ExternalPaymentDetails}
     * @memberof PaymentRecord
     */
    externalDetails?: ExternalPaymentDetails;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    locationId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    referenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    employeeId?: string;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof PaymentRecord
     */
    riskEvaluation?: RiskEvaluation;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    buyerEmailAddress?: string;
    /**
     * 
     * @type {Address}
     * @memberof PaymentRecord
     */
    billingAddress?: Address;
    /**
     * 
     * @type {Address}
     * @memberof PaymentRecord
     */
    shippingAddress?: Address;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentRecord
     */
    capabilities?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    receiptNumber?: string;
    /**
     * 
     * @type {Url}
     * @memberof PaymentRecord
     */
    receiptUrl?: Url;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    versionToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    statementDescriptionIdentifier?: string;
    /**
     * 
     * @type {Date}
     * @memberof PaymentRecord
     */
    createdAt: Date;
    /**
     * 
     * @type {Date}
     * @memberof PaymentRecord
     */
    updatedAt: Date;
    /**
     * 
     * @type {number}
     * @memberof PaymentRecord
     */
    version: number;
}
/**
 * 
 * @export
 * @interface PaymentRefundRequest
 */
export interface PaymentRefundRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentRefundRequest
     */
    idempotencyKey: string;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRefundRequest
     */
    amountMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRefundRequest
     */
    appFee?: Money;
    /**
     * 
     * @type {string}
     * @memberof PaymentRefundRequest
     */
    reason?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PaymentStatus {
    APPROVED = <any> 'APPROVED',
    PENDING = <any> 'PENDING',
    COMPLETED = <any> 'COMPLETED',
    CANCELLED = <any> 'CANCELLED',
    FAILED = <any> 'FAILED'
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickClientExcludeKeyofClientVerifiedSigOrTrustedSig_
 */
export interface PickClientExcludeKeyofClientVerifiedSigOrTrustedSig_ {
    /**
     * 
     * @type {string}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig_
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig_
     */
    name: string;
    /**
     * 
     * @type {Url}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig_
     */
    logoUrl?: Url;
    /**
     * 
     * @type {Array<string>}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig_
     */
    redirectUris?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig_
     */
    secretKey: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig_
     */
    scopes: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PickClientExcludeKeyofClientVerifiedSigOrTrustedSig_
     */
    ownerId?: string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_
 */
export interface PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_ {
    /**
     * 
     * @type {string}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_
     */
    name: string;
    /**
     * 
     * @type {Money}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_
     */
    amountMoney: Money;
    /**
     * 
     * @type {Attributes}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_
     */
    attributes?: Attributes;
    /**
     * 300 word description of the item.
     * @type {string}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_
     */
    description?: string;
    /**
     * 
     * @type {MetaData}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_
     */
    metaData?: MetaData;
    /**
     * Max 10 images per item. Default image is the first in array.
     * @type {Array<Url>}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_
     */
    imageUrls?: Array<Url>;
    /**
     * 
     * @type {string}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_
     */
    sku?: string;
    /**
     * 
     * @type {ItemOrderDetails}
     * @memberof PickItemOrAmountMoneyOrAttributesOrDescriptionOrIdOrMetaDataOrImageUrlsOrNameOrSkuOrOrderDetails_
     */
    orderDetails?: ItemOrderDetails;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_
 */
export interface PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_ {
    /**
     * 
     * @type {string}
     * @memberof PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_
     */
    name: string;
    /**
     * 
     * @type {Url}
     * @memberof PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_
     */
    logoUrl?: Url;
    /**
     * 
     * @type {MerchantContactDetails}
     * @memberof PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_
     */
    contactDetails: MerchantContactDetails;
    /**
     * 
     * @type {Currency}
     * @memberof PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_
     */
    defaultCurrency: Currency;
}
/**
 * 
 * @export
 * @interface ProcessingFee
 */
export interface ProcessingFee {
    /**
     * 
     * @type {string}
     * @memberof ProcessingFee
     */
    effectiveAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessingFee
     */
    type?: string;
    /**
     * 
     * @type {Money}
     * @memberof ProcessingFee
     */
    amountMoney: Money;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PromptType {
    Consent = <any> 'consent',
    SelectAccount = <any> 'select_account',
    Login = <any> 'login',
    None = <any> 'none'
}
/**
 * 
 * @export
 * @interface RefundRecord
 */
export interface RefundRecord {
    /**
     * 
     * @type {string}
     * @memberof RefundRecord
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RefundRecord
     */
    paymentId: string;
    /**
     * 
     * @type {Money}
     * @memberof RefundRecord
     */
    amountMoney: Money;
    /**
     * 
     * @type {Money}
     * @memberof RefundRecord
     */
    appFee?: Money;
    /**
     * 
     * @type {RefundStatus}
     * @memberof RefundRecord
     */
    status: RefundStatus;
    /**
     * 
     * @type {Array<ProcessingFee>}
     * @memberof RefundRecord
     */
    processingFees?: Array<ProcessingFee>;
    /**
     * 
     * @type {string}
     * @memberof RefundRecord
     */
    locationId?: string;
    /**
     * 
     * @type {Date}
     * @memberof RefundRecord
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof RefundRecord
     */
    updatedAt?: Date;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RefundStatus {
    PENDING = <any> 'PENDING',
    COMPLETED = <any> 'COMPLETED',
    REJECTED = <any> 'REJECTED',
    FAILED = <any> 'FAILED'
}
/**
 * 
 * @export
 * @interface RequestResetParams
 */
export interface RequestResetParams {
    /**
     * 
     * @type {EmailAddress}
     * @memberof RequestResetParams
     */
    email: EmailAddress;
    /**
     * 
     * @type {string}
     * @memberof RequestResetParams
     */
    ip?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestResetParams
     */
    browser?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestResetParams
     */
    device?: string;
}
/**
 * 
 * @export
 * @interface RiskEvaluation
 */
export interface RiskEvaluation {
    /**
     * 
     * @type {string}
     * @memberof RiskEvaluation
     */
    createdAt?: string;
    /**
     * 
     * @type {RiskLevel}
     * @memberof RiskEvaluation
     */
    riskLevel: RiskLevel;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RiskLevel {
    LOW = <any> 'LOW',
    MODERATE = <any> 'MODERATE',
    HIGH = <any> 'HIGH'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Service {
    Square = <any> 'square',
    Stripe = <any> 'stripe'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SplitType {
    EQUAL = <any> 'EQUAL',
    BYITEM = <any> 'BY_ITEM',
    CUSTOM = <any> 'CUSTOM'
}
/**
 * 
 * @export
 * @interface Sublocality
 */
export interface Sublocality {
    /**
     * 
     * @type {string}
     * @memberof Sublocality
     */
    sublocality1: string;
    /**
     * 
     * @type {string}
     * @memberof Sublocality
     */
    sublocality2?: string;
    /**
     * 
     * @type {string}
     * @memberof Sublocality
     */
    sublocality3?: string;
}
/**
 * 
 * @export
 * @interface Tax
 */
export interface Tax {
    /**
     * 
     * @type {string}
     * @memberof Tax
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Tax
     */
    code: string;
    /**
     * 
     * @type {Money}
     * @memberof Tax
     */
    amountMoney: Money;
}
/**
 * 
 * @export
 * @interface TemplateEmailCreationParams
 */
export interface TemplateEmailCreationParams {
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof TemplateEmailCreationParams
     */
    to: Array<EmailAddress>;
    /**
     * 
     * @type {string}
     * @memberof TemplateEmailCreationParams
     */
    subject: string;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof TemplateEmailCreationParams
     */
    cc?: Array<EmailAddress>;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof TemplateEmailCreationParams
     */
    bcc?: Array<EmailAddress>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof TemplateEmailCreationParams
     */
    attachment?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof TemplateEmailCreationParams
     */
    html?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateEmailCreationParams
     */
    text?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateEmailCreationParams
     */
    templateName: string;
    /**
     * 
     * @type {ModelObject}
     * @memberof TemplateEmailCreationParams
     */
    variables?: ModelObject;
}
/**
 * 
 * @export
 * @interface TextEmailCreationParams
 */
export interface TextEmailCreationParams {
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof TextEmailCreationParams
     */
    to: Array<EmailAddress>;
    /**
     * 
     * @type {string}
     * @memberof TextEmailCreationParams
     */
    subject: string;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof TextEmailCreationParams
     */
    cc?: Array<EmailAddress>;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof TextEmailCreationParams
     */
    bcc?: Array<EmailAddress>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof TextEmailCreationParams
     */
    attachment?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof TextEmailCreationParams
     */
    text: string;
    /**
     * 
     * @type {string}
     * @memberof TextEmailCreationParams
     */
    html?: string;
    /**
     * 
     * @type {string}
     * @memberof TextEmailCreationParams
     */
    templateName?: string;
    /**
     * 
     * @type {ModelObject}
     * @memberof TextEmailCreationParams
     */
    variables?: ModelObject;
}
/**
 * URI linking to a resource or website.
 * @export
 */
export type Uri = string
/**
 * URL linking to a resource or website.
 * @export
 */
export type Url = string
/**
 * AccountsApi - fetch parameter creator
 * @export
 */
export const AccountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Supply an account JWT access token and delete the associated profile from it
         * @summary Delete an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(options: any = {}): FetchArgs {
            const localVarPath = `/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Hands In account by supplying the necessary details
         * @summary Create an account
         * @param {AccountCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(body: AccountCreationParams, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling create.');
            }
            const localVarPath = `/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccountCreationParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply an account JWT access token and receive all profile data stored by Hands In
         * @summary Retrieve account profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options: any = {}): FetchArgs {
            const localVarPath = `/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply an account JWT access token and retrieve the all the applications that are connected to this account
         * @summary List connected account applications
         * @param {string} [appName] 
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(appName?: string, pageNum?: number, pageSize?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/accounts/applications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required

            if (appName !== undefined) {
                localVarQueryParameter['appName'] = appName;
            }

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Supply an account JWT access token and delete the associated profile from it
         * @summary Delete an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration)._delete(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a Hands In account by supplying the necessary details
         * @summary Create an account
         * @param {AccountCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(body: AccountCreationParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountDTO> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).create(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Supply an account JWT access token and receive all profile data stored by Hands In
         * @summary Retrieve account profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountDTO> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getProfile(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Supply an account JWT access token and retrieve the all the applications that are connected to this account
         * @summary List connected account applications
         * @param {string} [appName] 
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(appName?: string, pageNum?: number, pageSize?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountApp>> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).listApplications(appName, pageNum, pageSize, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Supply an account JWT access token and delete the associated profile from it
         * @summary Delete an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(options?: any) {
            return AccountsApiFp(configuration)._delete(options)(fetch, basePath);
        },
        /**
         * Create a Hands In account by supplying the necessary details
         * @summary Create an account
         * @param {AccountCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(body: AccountCreationParams, options?: any) {
            return AccountsApiFp(configuration).create(body, options)(fetch, basePath);
        },
        /**
         * Supply an account JWT access token and receive all profile data stored by Hands In
         * @summary Retrieve account profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: any) {
            return AccountsApiFp(configuration).getProfile(options)(fetch, basePath);
        },
        /**
         * Supply an account JWT access token and retrieve the all the applications that are connected to this account
         * @summary List connected account applications
         * @param {string} [appName] 
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(appName?: string, pageNum?: number, pageSize?: number, limit?: number, options?: any) {
            return AccountsApiFp(configuration).listApplications(appName, pageNum, pageSize, limit, options)(fetch, basePath);
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Supply an account JWT access token and delete the associated profile from it
     * @summary Delete an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public _delete(options?: any) {
        return AccountsApiFp(this.configuration)._delete(options)(this.fetch, this.basePath);
    }

    /**
     * Create a Hands In account by supplying the necessary details
     * @summary Create an account
     * @param {AccountCreationParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public create(body: AccountCreationParams, options?: any) {
        return AccountsApiFp(this.configuration).create(body, options)(this.fetch, this.basePath);
    }

    /**
     * Supply an account JWT access token and receive all profile data stored by Hands In
     * @summary Retrieve account profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getProfile(options?: any) {
        return AccountsApiFp(this.configuration).getProfile(options)(this.fetch, this.basePath);
    }

    /**
     * Supply an account JWT access token and retrieve the all the applications that are connected to this account
     * @summary List connected account applications
     * @param {string} [appName] 
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listApplications(appName?: string, pageNum?: number, pageSize?: number, limit?: number, options?: any) {
        return AccountsApiFp(this.configuration).listApplications(appName, pageNum, pageSize, limit, options)(this.fetch, this.basePath);
    }

}
/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Supply an email and password to recieve a JWT token which gives acts as an identification token for all resources hosted by Hands In
         * @summary Login to your Hands In account
         * @param {LoginParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: LoginParams, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/authentication/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requesting a password reset will email a link to the account enabling them to reset their password
         * @summary Create a reset password request
         * @param {RequestResetParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset(body: RequestResetParams, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling requestPasswordReset.');
            }
            const localVarPath = `/authentication/request-reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RequestResetParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset account password
         * @summary Reset password
         * @param {PasswordResetParams} body 
         * @param {string} resetToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(body: PasswordResetParams, resetToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resetPassword.');
            }
            // verify required parameter 'resetToken' is not null or undefined
            if (resetToken === null || resetToken === undefined) {
                throw new RequiredError('resetToken','Required parameter resetToken was null or undefined when calling resetPassword.');
            }
            const localVarPath = `/authentication/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (resetToken !== undefined) {
                localVarQueryParameter['resetToken'] = resetToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordResetParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Supply an email and password to recieve a JWT token which gives acts as an identification token for all resources hosted by Hands In
         * @summary Login to your Hands In account
         * @param {LoginParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: LoginParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OAuthTokenResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Requesting a password reset will email a link to the account enabling them to reset their password
         * @summary Create a reset password request
         * @param {RequestResetParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset(body: RequestResetParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OAuthTokenResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).requestPasswordReset(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reset account password
         * @summary Reset password
         * @param {PasswordResetParams} body 
         * @param {string} resetToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(body: PasswordResetParams, resetToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).resetPassword(body, resetToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Supply an email and password to recieve a JWT token which gives acts as an identification token for all resources hosted by Hands In
         * @summary Login to your Hands In account
         * @param {LoginParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: LoginParams, options?: any) {
            return AuthenticationApiFp(configuration).login(body, options)(fetch, basePath);
        },
        /**
         * Requesting a password reset will email a link to the account enabling them to reset their password
         * @summary Create a reset password request
         * @param {RequestResetParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset(body: RequestResetParams, options?: any) {
            return AuthenticationApiFp(configuration).requestPasswordReset(body, options)(fetch, basePath);
        },
        /**
         * Reset account password
         * @summary Reset password
         * @param {PasswordResetParams} body 
         * @param {string} resetToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(body: PasswordResetParams, resetToken: string, options?: any) {
            return AuthenticationApiFp(configuration).resetPassword(body, resetToken, options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Supply an email and password to recieve a JWT token which gives acts as an identification token for all resources hosted by Hands In
     * @summary Login to your Hands In account
     * @param {LoginParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(body: LoginParams, options?: any) {
        return AuthenticationApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

    /**
     * Requesting a password reset will email a link to the account enabling them to reset their password
     * @summary Create a reset password request
     * @param {RequestResetParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public requestPasswordReset(body: RequestResetParams, options?: any) {
        return AuthenticationApiFp(this.configuration).requestPasswordReset(body, options)(this.fetch, this.basePath);
    }

    /**
     * Reset account password
     * @summary Reset password
     * @param {PasswordResetParams} body 
     * @param {string} resetToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public resetPassword(body: PasswordResetParams, resetToken: string, options?: any) {
        return AuthenticationApiFp(this.configuration).resetPassword(body, resetToken, options)(this.fetch, this.basePath);
    }

}
/**
 * CheckoutsApi - fetch parameter creator
 * @export
 */
export const CheckoutsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
         * @summary Create a checkout session
         * @param {CheckoutSessionCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout(body: CheckoutSessionCreationParams, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCheckout.');
            }
            const localVarPath = `/checkouts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutSessionCreationParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique dispute ID and receive corresponding checkout details.
         * @summary Retrieve a checkout session
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckout(checkoutId: string, options: any = {}): FetchArgs {
            // verify required parameter 'checkoutId' is not null or undefined
            if (checkoutId === null || checkoutId === undefined) {
                throw new RequiredError('checkoutId','Required parameter checkoutId was null or undefined when calling getCheckout.');
            }
            const localVarPath = `/checkouts/{checkoutId}`
                .replace(`{${"checkoutId"}}`, encodeURIComponent(String(checkoutId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of checkout sessions by supplying the correct parameters.
         * @summary List all checkout sessions
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCheckouts(pageNum?: number, pageSize?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/checkouts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a checkout session by supplying the correct parameters.
         * @summary Update a checkout session
         * @param {CheckoutSessionCreationParams} body 
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckout(body: CheckoutSessionCreationParams, checkoutId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCheckout.');
            }
            // verify required parameter 'checkoutId' is not null or undefined
            if (checkoutId === null || checkoutId === undefined) {
                throw new RequiredError('checkoutId','Required parameter checkoutId was null or undefined when calling updateCheckout.');
            }
            const localVarPath = `/checkouts/{checkoutId}`
                .replace(`{${"checkoutId"}}`, encodeURIComponent(String(checkoutId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutSessionCreationParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutsApi - functional programming interface
 * @export
 */
export const CheckoutsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
         * @summary Create a checkout session
         * @param {CheckoutSessionCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout(body: CheckoutSessionCreationParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutSession> {
            const localVarFetchArgs = CheckoutsApiFetchParamCreator(configuration).createCheckout(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Supply the unique dispute ID and receive corresponding checkout details.
         * @summary Retrieve a checkout session
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckout(checkoutId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutSession> {
            const localVarFetchArgs = CheckoutsApiFetchParamCreator(configuration).getCheckout(checkoutId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of checkout sessions by supplying the correct parameters.
         * @summary List all checkout sessions
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCheckouts(pageNum?: number, pageSize?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CheckoutSession>> {
            const localVarFetchArgs = CheckoutsApiFetchParamCreator(configuration).listCheckouts(pageNum, pageSize, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a checkout session by supplying the correct parameters.
         * @summary Update a checkout session
         * @param {CheckoutSessionCreationParams} body 
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckout(body: CheckoutSessionCreationParams, checkoutId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutSession> {
            const localVarFetchArgs = CheckoutsApiFetchParamCreator(configuration).updateCheckout(body, checkoutId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckoutsApi - factory interface
 * @export
 */
export const CheckoutsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
         * @summary Create a checkout session
         * @param {CheckoutSessionCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout(body: CheckoutSessionCreationParams, options?: any) {
            return CheckoutsApiFp(configuration).createCheckout(body, options)(fetch, basePath);
        },
        /**
         * Supply the unique dispute ID and receive corresponding checkout details.
         * @summary Retrieve a checkout session
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckout(checkoutId: string, options?: any) {
            return CheckoutsApiFp(configuration).getCheckout(checkoutId, options)(fetch, basePath);
        },
        /**
         * Retrieve a list of checkout sessions by supplying the correct parameters.
         * @summary List all checkout sessions
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCheckouts(pageNum?: number, pageSize?: number, limit?: number, options?: any) {
            return CheckoutsApiFp(configuration).listCheckouts(pageNum, pageSize, limit, options)(fetch, basePath);
        },
        /**
         * Update a checkout session by supplying the correct parameters.
         * @summary Update a checkout session
         * @param {CheckoutSessionCreationParams} body 
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckout(body: CheckoutSessionCreationParams, checkoutId: string, options?: any) {
            return CheckoutsApiFp(configuration).updateCheckout(body, checkoutId, options)(fetch, basePath);
        },
    };
};

/**
 * CheckoutsApi - object-oriented interface
 * @export
 * @class CheckoutsApi
 * @extends {BaseAPI}
 */
export class CheckoutsApi extends BaseAPI {
    /**
     * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
     * @summary Create a checkout session
     * @param {CheckoutSessionCreationParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public createCheckout(body: CheckoutSessionCreationParams, options?: any) {
        return CheckoutsApiFp(this.configuration).createCheckout(body, options)(this.fetch, this.basePath);
    }

    /**
     * Supply the unique dispute ID and receive corresponding checkout details.
     * @summary Retrieve a checkout session
     * @param {string} checkoutId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public getCheckout(checkoutId: string, options?: any) {
        return CheckoutsApiFp(this.configuration).getCheckout(checkoutId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a list of checkout sessions by supplying the correct parameters.
     * @summary List all checkout sessions
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public listCheckouts(pageNum?: number, pageSize?: number, limit?: number, options?: any) {
        return CheckoutsApiFp(this.configuration).listCheckouts(pageNum, pageSize, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Update a checkout session by supplying the correct parameters.
     * @summary Update a checkout session
     * @param {CheckoutSessionCreationParams} body 
     * @param {string} checkoutId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public updateCheckout(body: CheckoutSessionCreationParams, checkoutId: string, options?: any) {
        return CheckoutsApiFp(this.configuration).updateCheckout(body, checkoutId, options)(this.fetch, this.basePath);
    }

}
/**
 * CustomersApi - fetch parameter creator
 * @export
 */
export const CustomersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Customer
         * @param {CustomerCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(body: CustomerCreationParams, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCustomer.');
            }
            const localVarPath = `/customers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerCreationParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling deleteCustomer.');
            }
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique customer ID and recieve the corresponding customer.
         * @summary Retrieve a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getCustomer.');
            }
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Customer
         * @param {CustomerCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(body: CustomerCreationParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).createCustomer(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a Customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).deleteCustomer(customerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Supply the unique customer ID and recieve the corresponding customer.
         * @summary Retrieve a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).getCustomer(customerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a Customer
         * @param {CustomerCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(body: CustomerCreationParams, options?: any) {
            return CustomersApiFp(configuration).createCustomer(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a Customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options?: any) {
            return CustomersApiFp(configuration).deleteCustomer(customerId, options)(fetch, basePath);
        },
        /**
         * Supply the unique customer ID and recieve the corresponding customer.
         * @summary Retrieve a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any) {
            return CustomersApiFp(configuration).getCustomer(customerId, options)(fetch, basePath);
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * 
     * @summary Create a Customer
     * @param {CustomerCreationParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomer(body: CustomerCreationParams, options?: any) {
        return CustomersApiFp(this.configuration).createCustomer(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a Customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomer(customerId: string, options?: any) {
        return CustomersApiFp(this.configuration).deleteCustomer(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Supply the unique customer ID and recieve the corresponding customer.
     * @summary Retrieve a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomer(customerId: string, options?: any) {
        return CustomersApiFp(this.configuration).getCustomer(customerId, options)(this.fetch, this.basePath);
    }

}
/**
 * EmailsApi - fetch parameter creator
 * @export
 */
export const EmailsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve email details given the email ID
         * @summary Retrieve an email
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling getEmail.');
            }
            const localVarPath = `/emails/{emailId}`
                .replace(`{${"emailId"}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of emails given the required parameters
         * @summary List emails
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails(pageNum?: number, pageSize?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/emails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from handsin by providing the parameters
         * @summary Send an email
         * @param {EmailCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(body: EmailCreationParams, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendEmail.');
            }
            const localVarPath = `/emails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCreationParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailsApi - functional programming interface
 * @export
 */
export const EmailsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve email details given the email ID
         * @summary Retrieve an email
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = EmailsApiFetchParamCreator(configuration).getEmail(emailId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of emails given the required parameters
         * @summary List emails
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails(pageNum?: number, pageSize?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Email>> {
            const localVarFetchArgs = EmailsApiFetchParamCreator(configuration).listEmails(pageNum, pageSize, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from handsin by providing the parameters
         * @summary Send an email
         * @param {EmailCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(body: EmailCreationParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = EmailsApiFetchParamCreator(configuration).sendEmail(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmailsApi - factory interface
 * @export
 */
export const EmailsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve email details given the email ID
         * @summary Retrieve an email
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(emailId: string, options?: any) {
            return EmailsApiFp(configuration).getEmail(emailId, options)(fetch, basePath);
        },
        /**
         * Retrieve a list of emails given the required parameters
         * @summary List emails
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails(pageNum?: number, pageSize?: number, limit?: number, options?: any) {
            return EmailsApiFp(configuration).listEmails(pageNum, pageSize, limit, options)(fetch, basePath);
        },
        /**
         * Send an email from handsin by providing the parameters
         * @summary Send an email
         * @param {EmailCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(body: EmailCreationParams, options?: any) {
            return EmailsApiFp(configuration).sendEmail(body, options)(fetch, basePath);
        },
    };
};

/**
 * EmailsApi - object-oriented interface
 * @export
 * @class EmailsApi
 * @extends {BaseAPI}
 */
export class EmailsApi extends BaseAPI {
    /**
     * Retrieve email details given the email ID
     * @summary Retrieve an email
     * @param {string} emailId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailsApi
     */
    public getEmail(emailId: string, options?: any) {
        return EmailsApiFp(this.configuration).getEmail(emailId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a list of emails given the required parameters
     * @summary List emails
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailsApi
     */
    public listEmails(pageNum?: number, pageSize?: number, limit?: number, options?: any) {
        return EmailsApiFp(this.configuration).listEmails(pageNum, pageSize, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Send an email from handsin by providing the parameters
     * @summary Send an email
     * @param {EmailCreationParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailsApi
     */
    public sendEmail(body: EmailCreationParams, options?: any) {
        return EmailsApiFp(this.configuration).sendEmail(body, options)(this.fetch, this.basePath);
    }

}
/**
 * GroupPaymentsApi - fetch parameter creator
 * @export
 */
export const GroupPaymentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a group payment
         * @param {GroupPaymentIdCancelBody} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupPayment(body: GroupPaymentIdCancelBody, groupPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cancelGroupPayment.');
            }
            // verify required parameter 'groupPaymentId' is not null or undefined
            if (groupPaymentId === null || groupPaymentId === undefined) {
                throw new RequiredError('groupPaymentId','Required parameter groupPaymentId was null or undefined when calling cancelGroupPayment.');
            }
            const localVarPath = `/group-payments/{groupPaymentId}/cancel`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GroupPaymentIdCancelBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a group payment
         * @param {CreateGroupPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPayment(body: CreateGroupPaymentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createGroupPayment.');
            }
            const localVarPath = `/group-payments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateGroupPaymentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique group payment ID and recieve the corresponding group payment.
         * @summary Retrieve a group payment
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPayment(groupPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupPaymentId' is not null or undefined
            if (groupPaymentId === null || groupPaymentId === undefined) {
                throw new RequiredError('groupPaymentId','Required parameter groupPaymentId was null or undefined when calling getGroupPayment.');
            }
            const localVarPath = `/group-payments/{groupPaymentId}`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all group payment refunds
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPaymentRefunds(groupPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupPaymentId' is not null or undefined
            if (groupPaymentId === null || groupPaymentId === undefined) {
                throw new RequiredError('groupPaymentId','Required parameter groupPaymentId was null or undefined when calling getGroupPaymentRefunds.');
            }
            const localVarPath = `/group-payments/{groupPaymentId}/refunds`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a group payment
         * @param {JoinGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroupPayment(body: JoinGroupPaymentRequest, groupPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling joinGroupPayment.');
            }
            // verify required parameter 'groupPaymentId' is not null or undefined
            if (groupPaymentId === null || groupPaymentId === undefined) {
                throw new RequiredError('groupPaymentId','Required parameter groupPaymentId was null or undefined when calling joinGroupPayment.');
            }
            const localVarPath = `/group-payments/{groupPaymentId}/join`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JoinGroupPaymentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kick member from a group payment
         * @param {KickGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickGroupPayment(body: KickGroupPaymentRequest, groupPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling kickGroupPayment.');
            }
            // verify required parameter 'groupPaymentId' is not null or undefined
            if (groupPaymentId === null || groupPaymentId === undefined) {
                throw new RequiredError('groupPaymentId','Required parameter groupPaymentId was null or undefined when calling kickGroupPayment.');
            }
            const localVarPath = `/group-payments/{groupPaymentId}/kick`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KickGroupPaymentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave a group payment
         * @param {LeaveGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroupPayment(body: LeaveGroupPaymentRequest, groupPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling leaveGroupPayment.');
            }
            // verify required parameter 'groupPaymentId' is not null or undefined
            if (groupPaymentId === null || groupPaymentId === undefined) {
                throw new RequiredError('groupPaymentId','Required parameter groupPaymentId was null or undefined when calling leaveGroupPayment.');
            }
            const localVarPath = `/group-payments/{groupPaymentId}/leave`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LeaveGroupPaymentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all group payments
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupPayments(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options: any = {}): FetchArgs {
            const localVarPath = `/group-payments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Collect a payment from an individual user that is intended to be part of a group payment.
         * @summary Pay into a group payment
         * @param {PayIntoGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInto(body: PayIntoGroupPaymentRequest, groupPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling payInto.');
            }
            // verify required parameter 'groupPaymentId' is not null or undefined
            if (groupPaymentId === null || groupPaymentId === undefined) {
                throw new RequiredError('groupPaymentId','Required parameter groupPaymentId was null or undefined when calling payInto.');
            }
            const localVarPath = `/group-payments/{groupPaymentId}/pay`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PayIntoGroupPaymentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a full refund back to each customer that paid into the supplied group payment.
         * @summary Refund a group payment
         * @param {GroupPaymentRefundRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundGroupPayment(body: GroupPaymentRefundRequest, groupPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling refundGroupPayment.');
            }
            // verify required parameter 'groupPaymentId' is not null or undefined
            if (groupPaymentId === null || groupPaymentId === undefined) {
                throw new RequiredError('groupPaymentId','Required parameter groupPaymentId was null or undefined when calling refundGroupPayment.');
            }
            const localVarPath = `/group-payments/{groupPaymentId}/refunds`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GroupPaymentRefundRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a group payment
         * @param {GroupPaymentUpdateParams} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPayment(body: GroupPaymentUpdateParams, groupPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateGroupPayment.');
            }
            // verify required parameter 'groupPaymentId' is not null or undefined
            if (groupPaymentId === null || groupPaymentId === undefined) {
                throw new RequiredError('groupPaymentId','Required parameter groupPaymentId was null or undefined when calling updateGroupPayment.');
            }
            const localVarPath = `/group-payments/{groupPaymentId}`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GroupPaymentUpdateParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupPaymentsApi - functional programming interface
 * @export
 */
export const GroupPaymentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a group payment
         * @param {GroupPaymentIdCancelBody} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupPayment(body: GroupPaymentIdCancelBody, groupPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPaymentRecord> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).cancelGroupPayment(body, groupPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a group payment
         * @param {CreateGroupPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPayment(body: CreateGroupPaymentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPaymentRecord> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).createGroupPayment(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Supply the unique group payment ID and recieve the corresponding group payment.
         * @summary Retrieve a group payment
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPayment(groupPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPaymentRecord> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).getGroupPayment(groupPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all group payment refunds
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPaymentRefunds(groupPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RefundRecord>> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).getGroupPaymentRefunds(groupPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Join a group payment
         * @param {JoinGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroupPayment(body: JoinGroupPaymentRequest, groupPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPaymentRecord> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).joinGroupPayment(body, groupPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kick member from a group payment
         * @param {KickGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickGroupPayment(body: KickGroupPaymentRequest, groupPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPaymentRecord> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).kickGroupPayment(body, groupPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Leave a group payment
         * @param {LeaveGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroupPayment(body: LeaveGroupPaymentRequest, groupPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPaymentRecord> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).leaveGroupPayment(body, groupPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all group payments
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupPayments(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupPaymentRecord>> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).listGroupPayments(pageNum, pageSize, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Collect a payment from an individual user that is intended to be part of a group payment.
         * @summary Pay into a group payment
         * @param {PayIntoGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInto(body: PayIntoGroupPaymentRequest, groupPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPaymentRecord> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).payInto(body, groupPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a full refund back to each customer that paid into the supplied group payment.
         * @summary Refund a group payment
         * @param {GroupPaymentRefundRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundGroupPayment(body: GroupPaymentRefundRequest, groupPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RefundRecord>> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).refundGroupPayment(body, groupPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a group payment
         * @param {GroupPaymentUpdateParams} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPayment(body: GroupPaymentUpdateParams, groupPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPaymentRecord> {
            const localVarFetchArgs = GroupPaymentsApiFetchParamCreator(configuration).updateGroupPayment(body, groupPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GroupPaymentsApi - factory interface
 * @export
 */
export const GroupPaymentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Cancel a group payment
         * @param {GroupPaymentIdCancelBody} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupPayment(body: GroupPaymentIdCancelBody, groupPaymentId: string, options?: any) {
            return GroupPaymentsApiFp(configuration).cancelGroupPayment(body, groupPaymentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a group payment
         * @param {CreateGroupPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPayment(body: CreateGroupPaymentRequest, options?: any) {
            return GroupPaymentsApiFp(configuration).createGroupPayment(body, options)(fetch, basePath);
        },
        /**
         * Supply the unique group payment ID and recieve the corresponding group payment.
         * @summary Retrieve a group payment
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPayment(groupPaymentId: string, options?: any) {
            return GroupPaymentsApiFp(configuration).getGroupPayment(groupPaymentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all group payment refunds
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPaymentRefunds(groupPaymentId: string, options?: any) {
            return GroupPaymentsApiFp(configuration).getGroupPaymentRefunds(groupPaymentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Join a group payment
         * @param {JoinGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroupPayment(body: JoinGroupPaymentRequest, groupPaymentId: string, options?: any) {
            return GroupPaymentsApiFp(configuration).joinGroupPayment(body, groupPaymentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kick member from a group payment
         * @param {KickGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickGroupPayment(body: KickGroupPaymentRequest, groupPaymentId: string, options?: any) {
            return GroupPaymentsApiFp(configuration).kickGroupPayment(body, groupPaymentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Leave a group payment
         * @param {LeaveGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroupPayment(body: LeaveGroupPaymentRequest, groupPaymentId: string, options?: any) {
            return GroupPaymentsApiFp(configuration).leaveGroupPayment(body, groupPaymentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all group payments
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupPayments(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any) {
            return GroupPaymentsApiFp(configuration).listGroupPayments(pageNum, pageSize, limit, options)(fetch, basePath);
        },
        /**
         * Collect a payment from an individual user that is intended to be part of a group payment.
         * @summary Pay into a group payment
         * @param {PayIntoGroupPaymentRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInto(body: PayIntoGroupPaymentRequest, groupPaymentId: string, options?: any) {
            return GroupPaymentsApiFp(configuration).payInto(body, groupPaymentId, options)(fetch, basePath);
        },
        /**
         * Create a full refund back to each customer that paid into the supplied group payment.
         * @summary Refund a group payment
         * @param {GroupPaymentRefundRequest} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundGroupPayment(body: GroupPaymentRefundRequest, groupPaymentId: string, options?: any) {
            return GroupPaymentsApiFp(configuration).refundGroupPayment(body, groupPaymentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a group payment
         * @param {GroupPaymentUpdateParams} body 
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPayment(body: GroupPaymentUpdateParams, groupPaymentId: string, options?: any) {
            return GroupPaymentsApiFp(configuration).updateGroupPayment(body, groupPaymentId, options)(fetch, basePath);
        },
    };
};

/**
 * GroupPaymentsApi - object-oriented interface
 * @export
 * @class GroupPaymentsApi
 * @extends {BaseAPI}
 */
export class GroupPaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Cancel a group payment
     * @param {GroupPaymentIdCancelBody} body 
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public cancelGroupPayment(body: GroupPaymentIdCancelBody, groupPaymentId: string, options?: any) {
        return GroupPaymentsApiFp(this.configuration).cancelGroupPayment(body, groupPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a group payment
     * @param {CreateGroupPaymentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public createGroupPayment(body: CreateGroupPaymentRequest, options?: any) {
        return GroupPaymentsApiFp(this.configuration).createGroupPayment(body, options)(this.fetch, this.basePath);
    }

    /**
     * Supply the unique group payment ID and recieve the corresponding group payment.
     * @summary Retrieve a group payment
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public getGroupPayment(groupPaymentId: string, options?: any) {
        return GroupPaymentsApiFp(this.configuration).getGroupPayment(groupPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all group payment refunds
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public getGroupPaymentRefunds(groupPaymentId: string, options?: any) {
        return GroupPaymentsApiFp(this.configuration).getGroupPaymentRefunds(groupPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Join a group payment
     * @param {JoinGroupPaymentRequest} body 
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public joinGroupPayment(body: JoinGroupPaymentRequest, groupPaymentId: string, options?: any) {
        return GroupPaymentsApiFp(this.configuration).joinGroupPayment(body, groupPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Kick member from a group payment
     * @param {KickGroupPaymentRequest} body 
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public kickGroupPayment(body: KickGroupPaymentRequest, groupPaymentId: string, options?: any) {
        return GroupPaymentsApiFp(this.configuration).kickGroupPayment(body, groupPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Leave a group payment
     * @param {LeaveGroupPaymentRequest} body 
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public leaveGroupPayment(body: LeaveGroupPaymentRequest, groupPaymentId: string, options?: any) {
        return GroupPaymentsApiFp(this.configuration).leaveGroupPayment(body, groupPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all group payments
     * @param {ModelInteger} [pageNum] 
     * @param {ModelInteger} [pageSize] 
     * @param {ModelInteger} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public listGroupPayments(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any) {
        return GroupPaymentsApiFp(this.configuration).listGroupPayments(pageNum, pageSize, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Collect a payment from an individual user that is intended to be part of a group payment.
     * @summary Pay into a group payment
     * @param {PayIntoGroupPaymentRequest} body 
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public payInto(body: PayIntoGroupPaymentRequest, groupPaymentId: string, options?: any) {
        return GroupPaymentsApiFp(this.configuration).payInto(body, groupPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * Create a full refund back to each customer that paid into the supplied group payment.
     * @summary Refund a group payment
     * @param {GroupPaymentRefundRequest} body 
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public refundGroupPayment(body: GroupPaymentRefundRequest, groupPaymentId: string, options?: any) {
        return GroupPaymentsApiFp(this.configuration).refundGroupPayment(body, groupPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a group payment
     * @param {GroupPaymentUpdateParams} body 
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public updateGroupPayment(body: GroupPaymentUpdateParams, groupPaymentId: string, options?: any) {
        return GroupPaymentsApiFp(this.configuration).updateGroupPayment(body, groupPaymentId, options)(this.fetch, this.basePath);
    }

}
/**
 * ItemsApi - fetch parameter creator
 * @export
 */
export const ItemsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an item by supplying the correct parameters.
         * @summary Create an item
         * @param {ItemCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(body: ItemCreationParams, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createItem.');
            }
            const localVarPath = `/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItemCreationParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a item session by supplying the correct parameters.
         * @summary Delete an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(itemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItem.');
            }
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique dispute ID and receive corresponding item details.
         * @summary Retrieve an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItem.');
            }
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all items by supplying a list of their Ids. Please note, that if any Id's are not valid, then they will just be ignored (no error is thrown)
         * @summary Retrieve multiple items
         * @param {ItemListParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(body: ItemListParams, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getItems.');
            }
            const localVarPath = `/items/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItemListParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of items by supplying the correct parameters.
         * @summary List all items
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(pageNum?: number, pageSize?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a item by supplying the correct parameters.
         * @summary Update an item
         * @param {ItemUpdateParams} body 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(body: ItemUpdateParams, itemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItem.');
            }
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItemUpdateParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create an item by supplying the correct parameters.
         * @summary Create an item
         * @param {ItemCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(body: ItemCreationParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Item> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).createItem(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a item session by supplying the correct parameters.
         * @summary Delete an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(itemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Item> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).deleteItem(itemId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Supply the unique dispute ID and receive corresponding item details.
         * @summary Retrieve an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Item> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).getItem(itemId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all items by supplying a list of their Ids. Please note, that if any Id's are not valid, then they will just be ignored (no error is thrown)
         * @summary Retrieve multiple items
         * @param {ItemListParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(body: ItemListParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Item>> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).getItems(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of items by supplying the correct parameters.
         * @summary List all items
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(pageNum?: number, pageSize?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Item>> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).listItems(pageNum, pageSize, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a item by supplying the correct parameters.
         * @summary Update an item
         * @param {ItemUpdateParams} body 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(body: ItemUpdateParams, itemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Item> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).updateItem(body, itemId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create an item by supplying the correct parameters.
         * @summary Create an item
         * @param {ItemCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(body: ItemCreationParams, options?: any) {
            return ItemsApiFp(configuration).createItem(body, options)(fetch, basePath);
        },
        /**
         * Update a item session by supplying the correct parameters.
         * @summary Delete an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(itemId: string, options?: any) {
            return ItemsApiFp(configuration).deleteItem(itemId, options)(fetch, basePath);
        },
        /**
         * Supply the unique dispute ID and receive corresponding item details.
         * @summary Retrieve an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, options?: any) {
            return ItemsApiFp(configuration).getItem(itemId, options)(fetch, basePath);
        },
        /**
         * Retrieve all items by supplying a list of their Ids. Please note, that if any Id's are not valid, then they will just be ignored (no error is thrown)
         * @summary Retrieve multiple items
         * @param {ItemListParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(body: ItemListParams, options?: any) {
            return ItemsApiFp(configuration).getItems(body, options)(fetch, basePath);
        },
        /**
         * Retrieve a list of items by supplying the correct parameters.
         * @summary List all items
         * @param {number} [pageNum] 
         * @param {number} [pageSize] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(pageNum?: number, pageSize?: number, limit?: number, options?: any) {
            return ItemsApiFp(configuration).listItems(pageNum, pageSize, limit, options)(fetch, basePath);
        },
        /**
         * Update a item by supplying the correct parameters.
         * @summary Update an item
         * @param {ItemUpdateParams} body 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(body: ItemUpdateParams, itemId: string, options?: any) {
            return ItemsApiFp(configuration).updateItem(body, itemId, options)(fetch, basePath);
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * Create an item by supplying the correct parameters.
     * @summary Create an item
     * @param {ItemCreationParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItem(body: ItemCreationParams, options?: any) {
        return ItemsApiFp(this.configuration).createItem(body, options)(this.fetch, this.basePath);
    }

    /**
     * Update a item session by supplying the correct parameters.
     * @summary Delete an item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteItem(itemId: string, options?: any) {
        return ItemsApiFp(this.configuration).deleteItem(itemId, options)(this.fetch, this.basePath);
    }

    /**
     * Supply the unique dispute ID and receive corresponding item details.
     * @summary Retrieve an item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItem(itemId: string, options?: any) {
        return ItemsApiFp(this.configuration).getItem(itemId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all items by supplying a list of their Ids. Please note, that if any Id's are not valid, then they will just be ignored (no error is thrown)
     * @summary Retrieve multiple items
     * @param {ItemListParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItems(body: ItemListParams, options?: any) {
        return ItemsApiFp(this.configuration).getItems(body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a list of items by supplying the correct parameters.
     * @summary List all items
     * @param {number} [pageNum] 
     * @param {number} [pageSize] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public listItems(pageNum?: number, pageSize?: number, limit?: number, options?: any) {
        return ItemsApiFp(this.configuration).listItems(pageNum, pageSize, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Update a item by supplying the correct parameters.
     * @summary Update an item
     * @param {ItemUpdateParams} body 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateItem(body: ItemUpdateParams, itemId: string, options?: any) {
        return ItemsApiFp(this.configuration).updateItem(body, itemId, options)(this.fetch, this.basePath);
    }

}
/**
 * MerchantApi - fetch parameter creator
 * @export
 */
export const MerchantApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provide a ID token to create a merchant. Receive a JWT access token that gives all scope to account.
         * @summary Create a merchant account
         * @param {PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchant(body: PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createMerchant.');
            }
            const localVarPath = `/merchants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a merchant account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchant(options: any = {}): FetchArgs {
            const localVarPath = `/merchants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply a merchant JWT token and retrieve merchant data
         * @summary Retrieve merchant data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchant(options: any = {}): FetchArgs {
            const localVarPath = `/merchants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invite a merchant account team
         * @param {MerchantIdInviteBody} body 
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMerchant(body: MerchantIdInviteBody, merchantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling inviteMerchant.');
            }
            // verify required parameter 'merchantId' is not null or undefined
            if (merchantId === null || merchantId === undefined) {
                throw new RequiredError('merchantId','Required parameter merchantId was null or undefined when calling inviteMerchant.');
            }
            const localVarPath = `/merchants/{merchantId}/invite`
                .replace(`{${"merchantId"}}`, encodeURIComponent(String(merchantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MerchantIdInviteBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply both the id token for the account, aswell as the access token, which would have been provided to you, through a link or email.
         * @summary Join a merchant account team
         * @param {string} merchantId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinMerchant(merchantId: string, key: string, options: any = {}): FetchArgs {
            // verify required parameter 'merchantId' is not null or undefined
            if (merchantId === null || merchantId === undefined) {
                throw new RequiredError('merchantId','Required parameter merchantId was null or undefined when calling joinMerchant.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling joinMerchant.');
            }
            const localVarPath = `/merchants/{merchantId}/join`
                .replace(`{${"merchantId"}}`, encodeURIComponent(String(merchantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange an account access token to get a resource token Which gives access to all the merhant scopes you have permission for
         * @summary Login to a merchant account
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMerchant(merchantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'merchantId' is not null or undefined
            if (merchantId === null || merchantId === undefined) {
                throw new RequiredError('merchantId','Required parameter merchantId was null or undefined when calling loginMerchant.');
            }
            const localVarPath = `/merchants/{merchantId}/token`
                .replace(`{${"merchantId"}}`, encodeURIComponent(String(merchantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication account-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply a merchant JWT token and email parameters to send an email through the handsin email service
         * @summary Send an email
         * @param {EmailCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailMerchant(body: EmailCreationParams, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendEmailMerchant.');
            }
            const localVarPath = `/merchants/sendEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCreationParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantApi - functional programming interface
 * @export
 */
export const MerchantApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provide a ID token to create a merchant. Receive a JWT access token that gives all scope to account.
         * @summary Create a merchant account
         * @param {PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchant(body: PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MerchantDTO> {
            const localVarFetchArgs = MerchantApiFetchParamCreator(configuration).createMerchant(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a merchant account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchant(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MerchantDTO> {
            const localVarFetchArgs = MerchantApiFetchParamCreator(configuration).deleteMerchant(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Supply a merchant JWT token and retrieve merchant data
         * @summary Retrieve merchant data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchant(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MerchantDTO> {
            const localVarFetchArgs = MerchantApiFetchParamCreator(configuration).getMerchant(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invite a merchant account team
         * @param {MerchantIdInviteBody} body 
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMerchant(body: MerchantIdInviteBody, merchantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MerchantDTO> {
            const localVarFetchArgs = MerchantApiFetchParamCreator(configuration).inviteMerchant(body, merchantId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Supply both the id token for the account, aswell as the access token, which would have been provided to you, through a link or email.
         * @summary Join a merchant account team
         * @param {string} merchantId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinMerchant(merchantId: string, key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MerchantDTO> {
            const localVarFetchArgs = MerchantApiFetchParamCreator(configuration).joinMerchant(merchantId, key, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Exchange an account access token to get a resource token Which gives access to all the merhant scopes you have permission for
         * @summary Login to a merchant account
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMerchant(merchantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OAuthTokenResponse> {
            const localVarFetchArgs = MerchantApiFetchParamCreator(configuration).loginMerchant(merchantId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Supply a merchant JWT token and email parameters to send an email through the handsin email service
         * @summary Send an email
         * @param {EmailCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailMerchant(body: EmailCreationParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = MerchantApiFetchParamCreator(configuration).sendEmailMerchant(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MerchantApi - factory interface
 * @export
 */
export const MerchantApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Provide a ID token to create a merchant. Receive a JWT access token that gives all scope to account.
         * @summary Create a merchant account
         * @param {PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchant(body: PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_, options?: any) {
            return MerchantApiFp(configuration).createMerchant(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a merchant account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchant(options?: any) {
            return MerchantApiFp(configuration).deleteMerchant(options)(fetch, basePath);
        },
        /**
         * Supply a merchant JWT token and retrieve merchant data
         * @summary Retrieve merchant data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchant(options?: any) {
            return MerchantApiFp(configuration).getMerchant(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invite a merchant account team
         * @param {MerchantIdInviteBody} body 
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMerchant(body: MerchantIdInviteBody, merchantId: string, options?: any) {
            return MerchantApiFp(configuration).inviteMerchant(body, merchantId, options)(fetch, basePath);
        },
        /**
         * Supply both the id token for the account, aswell as the access token, which would have been provided to you, through a link or email.
         * @summary Join a merchant account team
         * @param {string} merchantId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinMerchant(merchantId: string, key: string, options?: any) {
            return MerchantApiFp(configuration).joinMerchant(merchantId, key, options)(fetch, basePath);
        },
        /**
         * Exchange an account access token to get a resource token Which gives access to all the merhant scopes you have permission for
         * @summary Login to a merchant account
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMerchant(merchantId: string, options?: any) {
            return MerchantApiFp(configuration).loginMerchant(merchantId, options)(fetch, basePath);
        },
        /**
         * Supply a merchant JWT token and email parameters to send an email through the handsin email service
         * @summary Send an email
         * @param {EmailCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailMerchant(body: EmailCreationParams, options?: any) {
            return MerchantApiFp(configuration).sendEmailMerchant(body, options)(fetch, basePath);
        },
    };
};

/**
 * MerchantApi - object-oriented interface
 * @export
 * @class MerchantApi
 * @extends {BaseAPI}
 */
export class MerchantApi extends BaseAPI {
    /**
     * Provide a ID token to create a merchant. Receive a JWT access token that gives all scope to account.
     * @summary Create a merchant account
     * @param {PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public createMerchant(body: PickMerchantNameOrContactDetailsOrLogoUrlOrDefaultCurrency_, options?: any) {
        return MerchantApiFp(this.configuration).createMerchant(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a merchant account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public deleteMerchant(options?: any) {
        return MerchantApiFp(this.configuration).deleteMerchant(options)(this.fetch, this.basePath);
    }

    /**
     * Supply a merchant JWT token and retrieve merchant data
     * @summary Retrieve merchant data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public getMerchant(options?: any) {
        return MerchantApiFp(this.configuration).getMerchant(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invite a merchant account team
     * @param {MerchantIdInviteBody} body 
     * @param {string} merchantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public inviteMerchant(body: MerchantIdInviteBody, merchantId: string, options?: any) {
        return MerchantApiFp(this.configuration).inviteMerchant(body, merchantId, options)(this.fetch, this.basePath);
    }

    /**
     * Supply both the id token for the account, aswell as the access token, which would have been provided to you, through a link or email.
     * @summary Join a merchant account team
     * @param {string} merchantId 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public joinMerchant(merchantId: string, key: string, options?: any) {
        return MerchantApiFp(this.configuration).joinMerchant(merchantId, key, options)(this.fetch, this.basePath);
    }

    /**
     * Exchange an account access token to get a resource token Which gives access to all the merhant scopes you have permission for
     * @summary Login to a merchant account
     * @param {string} merchantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public loginMerchant(merchantId: string, options?: any) {
        return MerchantApiFp(this.configuration).loginMerchant(merchantId, options)(this.fetch, this.basePath);
    }

    /**
     * Supply a merchant JWT token and email parameters to send an email through the handsin email service
     * @summary Send an email
     * @param {EmailCreationParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public sendEmailMerchant(body: EmailCreationParams, options?: any) {
        return MerchantApiFp(this.configuration).sendEmailMerchant(body, options)(this.fetch, this.basePath);
    }

}
/**
 * MerchantConnectApi - fetch parameter creator
 * @export
 */
export const MerchantConnectApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Redirect merchant to payment service (e.g. square) authorisation page and connect service via Merchant Payment Connector
         * @summary Connect to Merchant Payment Service
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authoriseMerchantPaymentConnect(service: Service, options: any = {}): FetchArgs {
            // verify required parameter 'service' is not null or undefined
            if (service === null || service === undefined) {
                throw new RequiredError('service','Required parameter service was null or undefined when calling authoriseMerchantPaymentConnect.');
            }
            const localVarPath = `/merchant/{service}/connect`
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Connection to Merchant Payment Service Properties
         * @summary Get Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantPaymentConnect(service: Service, options: any = {}): FetchArgs {
            // verify required parameter 'service' is not null or undefined
            if (service === null || service === undefined) {
                throw new RequiredError('service','Required parameter service was null or undefined when calling getMerchantPaymentConnect.');
            }
            const localVarPath = `/merchant/{service}`
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain access token for merchant payment service account This is automatically hit by redirect url after authorizing payment service
         * @summary Obtain Merchant Payment Connection
         * @param {Service} service 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainMerchantPaymentConnect(service: Service, code?: string, state?: string, options: any = {}): FetchArgs {
            // verify required parameter 'service' is not null or undefined
            if (service === null || service === undefined) {
                throw new RequiredError('service','Required parameter service was null or undefined when calling obtainMerchantPaymentConnect.');
            }
            const localVarPath = `/merchant/{service}/obtain`
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-Authorise Connection to Merchant Payment Service
         * @summary Renew Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewMerchantPaymentConnect(service: Service, options: any = {}): FetchArgs {
            // verify required parameter 'service' is not null or undefined
            if (service === null || service === undefined) {
                throw new RequiredError('service','Required parameter service was null or undefined when calling renewMerchantPaymentConnect.');
            }
            const localVarPath = `/merchant/{service}/renew`
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke Connection Tokens to Merchant Payment Service
         * @summary Revoke Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMerchantPaymentConnect(service: Service, options: any = {}): FetchArgs {
            // verify required parameter 'service' is not null or undefined
            if (service === null || service === undefined) {
                throw new RequiredError('service','Required parameter service was null or undefined when calling revokeMerchantPaymentConnect.');
            }
            const localVarPath = `/merchant/{service}/revoke`
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantConnectApi - functional programming interface
 * @export
 */
export const MerchantConnectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Redirect merchant to payment service (e.g. square) authorisation page and connect service via Merchant Payment Connector
         * @summary Connect to Merchant Payment Service
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authoriseMerchantPaymentConnect(service: Service, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelObject> {
            const localVarFetchArgs = MerchantConnectApiFetchParamCreator(configuration).authoriseMerchantPaymentConnect(service, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Connection to Merchant Payment Service Properties
         * @summary Get Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantPaymentConnect(service: Service, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelObject> {
            const localVarFetchArgs = MerchantConnectApiFetchParamCreator(configuration).getMerchantPaymentConnect(service, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtain access token for merchant payment service account This is automatically hit by redirect url after authorizing payment service
         * @summary Obtain Merchant Payment Connection
         * @param {Service} service 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainMerchantPaymentConnect(service: Service, code?: string, state?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelObject> {
            const localVarFetchArgs = MerchantConnectApiFetchParamCreator(configuration).obtainMerchantPaymentConnect(service, code, state, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Re-Authorise Connection to Merchant Payment Service
         * @summary Renew Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewMerchantPaymentConnect(service: Service, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelObject> {
            const localVarFetchArgs = MerchantConnectApiFetchParamCreator(configuration).renewMerchantPaymentConnect(service, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Revoke Connection Tokens to Merchant Payment Service
         * @summary Revoke Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMerchantPaymentConnect(service: Service, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelObject> {
            const localVarFetchArgs = MerchantConnectApiFetchParamCreator(configuration).revokeMerchantPaymentConnect(service, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MerchantConnectApi - factory interface
 * @export
 */
export const MerchantConnectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Redirect merchant to payment service (e.g. square) authorisation page and connect service via Merchant Payment Connector
         * @summary Connect to Merchant Payment Service
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authoriseMerchantPaymentConnect(service: Service, options?: any) {
            return MerchantConnectApiFp(configuration).authoriseMerchantPaymentConnect(service, options)(fetch, basePath);
        },
        /**
         * Get Connection to Merchant Payment Service Properties
         * @summary Get Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantPaymentConnect(service: Service, options?: any) {
            return MerchantConnectApiFp(configuration).getMerchantPaymentConnect(service, options)(fetch, basePath);
        },
        /**
         * Obtain access token for merchant payment service account This is automatically hit by redirect url after authorizing payment service
         * @summary Obtain Merchant Payment Connection
         * @param {Service} service 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainMerchantPaymentConnect(service: Service, code?: string, state?: string, options?: any) {
            return MerchantConnectApiFp(configuration).obtainMerchantPaymentConnect(service, code, state, options)(fetch, basePath);
        },
        /**
         * Re-Authorise Connection to Merchant Payment Service
         * @summary Renew Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewMerchantPaymentConnect(service: Service, options?: any) {
            return MerchantConnectApiFp(configuration).renewMerchantPaymentConnect(service, options)(fetch, basePath);
        },
        /**
         * Revoke Connection Tokens to Merchant Payment Service
         * @summary Revoke Merchant Payment Connection
         * @param {Service} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMerchantPaymentConnect(service: Service, options?: any) {
            return MerchantConnectApiFp(configuration).revokeMerchantPaymentConnect(service, options)(fetch, basePath);
        },
    };
};

/**
 * MerchantConnectApi - object-oriented interface
 * @export
 * @class MerchantConnectApi
 * @extends {BaseAPI}
 */
export class MerchantConnectApi extends BaseAPI {
    /**
     * Redirect merchant to payment service (e.g. square) authorisation page and connect service via Merchant Payment Connector
     * @summary Connect to Merchant Payment Service
     * @param {Service} service 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantConnectApi
     */
    public authoriseMerchantPaymentConnect(service: Service, options?: any) {
        return MerchantConnectApiFp(this.configuration).authoriseMerchantPaymentConnect(service, options)(this.fetch, this.basePath);
    }

    /**
     * Get Connection to Merchant Payment Service Properties
     * @summary Get Merchant Payment Connection
     * @param {Service} service 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantConnectApi
     */
    public getMerchantPaymentConnect(service: Service, options?: any) {
        return MerchantConnectApiFp(this.configuration).getMerchantPaymentConnect(service, options)(this.fetch, this.basePath);
    }

    /**
     * Obtain access token for merchant payment service account This is automatically hit by redirect url after authorizing payment service
     * @summary Obtain Merchant Payment Connection
     * @param {Service} service 
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantConnectApi
     */
    public obtainMerchantPaymentConnect(service: Service, code?: string, state?: string, options?: any) {
        return MerchantConnectApiFp(this.configuration).obtainMerchantPaymentConnect(service, code, state, options)(this.fetch, this.basePath);
    }

    /**
     * Re-Authorise Connection to Merchant Payment Service
     * @summary Renew Merchant Payment Connection
     * @param {Service} service 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantConnectApi
     */
    public renewMerchantPaymentConnect(service: Service, options?: any) {
        return MerchantConnectApiFp(this.configuration).renewMerchantPaymentConnect(service, options)(this.fetch, this.basePath);
    }

    /**
     * Revoke Connection Tokens to Merchant Payment Service
     * @summary Revoke Merchant Payment Connection
     * @param {Service} service 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantConnectApi
     */
    public revokeMerchantPaymentConnect(service: Service, options?: any) {
        return MerchantConnectApiFp(this.configuration).revokeMerchantPaymentConnect(service, options)(this.fetch, this.basePath);
    }

}
/**
 * OrdersApi - fetch parameter creator
 * @export
 */
export const OrdersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an order
         * @param {OrderCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(body: OrderCreationParams, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createOrder.');
            }
            const localVarPath = `/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderCreationParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrder.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Orders
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options: any = {}): FetchArgs {
            const localVarPath = `/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an order
         * @param {PartialOrderCreationParams_} body 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(body: PartialOrderCreationParams_, orderId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrder.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PartialOrderCreationParams_" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an order
         * @param {OrderCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(body: OrderCreationParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).createOrder(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve an order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).getOrder(orderId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all Orders
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Order>> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).listOrders(pageNum, pageSize, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update an order
         * @param {PartialOrderCreationParams_} body 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(body: PartialOrderCreationParams_, orderId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).updateOrder(body, orderId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create an order
         * @param {OrderCreationParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(body: OrderCreationParams, options?: any) {
            return OrdersApiFp(configuration).createOrder(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve an order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, options?: any) {
            return OrdersApiFp(configuration).getOrder(orderId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all Orders
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any) {
            return OrdersApiFp(configuration).listOrders(pageNum, pageSize, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an order
         * @param {PartialOrderCreationParams_} body 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(body: PartialOrderCreationParams_, orderId: string, options?: any) {
            return OrdersApiFp(configuration).updateOrder(body, orderId, options)(fetch, basePath);
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @summary Create an order
     * @param {OrderCreationParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public createOrder(body: OrderCreationParams, options?: any) {
        return OrdersApiFp(this.configuration).createOrder(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve an order
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrder(orderId: string, options?: any) {
        return OrdersApiFp(this.configuration).getOrder(orderId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all Orders
     * @param {ModelInteger} [pageNum] 
     * @param {ModelInteger} [pageSize] 
     * @param {ModelInteger} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public listOrders(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any) {
        return OrdersApiFp(this.configuration).listOrders(pageNum, pageSize, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update an order
     * @param {PartialOrderCreationParams_} body 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public updateOrder(body: PartialOrderCreationParams_, orderId: string, options?: any) {
        return OrdersApiFp(this.configuration).updateOrder(body, orderId, options)(this.fetch, this.basePath);
    }

}
/**
 * PaymentsApi - fetch parameter creator
 * @export
 */
export const PaymentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment(paymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling cancelPayment.');
            }
            const localVarPath = `/payments/{paymentId}/cancel`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Collect a payment from an individual user
         * @summary Create a payment
         * @param {CreatePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(body: CreatePaymentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPayment.');
            }
            const localVarPath = `/payments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePaymentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique payment ID and receive corresponding payment details.
         * @summary Retrieve a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getPayment.');
            }
            const localVarPath = `/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all payment refunds
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentRefunds(paymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getPaymentRefunds.');
            }
            const localVarPath = `/payments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all payments
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options: any = {}): FetchArgs {
            const localVarPath = `/payments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a full or partial refund back to a customer, from a supplied payment.
         * @summary Refund a payment
         * @param {PaymentRefundRequest} body 
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(body: PaymentRefundRequest, paymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling refundPayment.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling refundPayment.');
            }
            const localVarPath = `/payments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentRefundRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment(paymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentRecord> {
            const localVarFetchArgs = PaymentsApiFetchParamCreator(configuration).cancelPayment(paymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Collect a payment from an individual user
         * @summary Create a payment
         * @param {CreatePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(body: CreatePaymentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentRecord> {
            const localVarFetchArgs = PaymentsApiFetchParamCreator(configuration).createPayment(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Supply the unique payment ID and receive corresponding payment details.
         * @summary Retrieve a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentRecord> {
            const localVarFetchArgs = PaymentsApiFetchParamCreator(configuration).getPayment(paymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all payment refunds
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentRefunds(paymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RefundRecord>> {
            const localVarFetchArgs = PaymentsApiFetchParamCreator(configuration).getPaymentRefunds(paymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all payments
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PaymentRecord>> {
            const localVarFetchArgs = PaymentsApiFetchParamCreator(configuration).listPayments(pageNum, pageSize, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a full or partial refund back to a customer, from a supplied payment.
         * @summary Refund a payment
         * @param {PaymentRefundRequest} body 
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(body: PaymentRefundRequest, paymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RefundRecord> {
            const localVarFetchArgs = PaymentsApiFetchParamCreator(configuration).refundPayment(body, paymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Cancel a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment(paymentId: string, options?: any) {
            return PaymentsApiFp(configuration).cancelPayment(paymentId, options)(fetch, basePath);
        },
        /**
         * Collect a payment from an individual user
         * @summary Create a payment
         * @param {CreatePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(body: CreatePaymentRequest, options?: any) {
            return PaymentsApiFp(configuration).createPayment(body, options)(fetch, basePath);
        },
        /**
         * Supply the unique payment ID and receive corresponding payment details.
         * @summary Retrieve a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId: string, options?: any) {
            return PaymentsApiFp(configuration).getPayment(paymentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all payment refunds
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentRefunds(paymentId: string, options?: any) {
            return PaymentsApiFp(configuration).getPaymentRefunds(paymentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all payments
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any) {
            return PaymentsApiFp(configuration).listPayments(pageNum, pageSize, limit, options)(fetch, basePath);
        },
        /**
         * Create a full or partial refund back to a customer, from a supplied payment.
         * @summary Refund a payment
         * @param {PaymentRefundRequest} body 
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(body: PaymentRefundRequest, paymentId: string, options?: any) {
            return PaymentsApiFp(configuration).refundPayment(body, paymentId, options)(fetch, basePath);
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Cancel a payment
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public cancelPayment(paymentId: string, options?: any) {
        return PaymentsApiFp(this.configuration).cancelPayment(paymentId, options)(this.fetch, this.basePath);
    }

    /**
     * Collect a payment from an individual user
     * @summary Create a payment
     * @param {CreatePaymentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createPayment(body: CreatePaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).createPayment(body, options)(this.fetch, this.basePath);
    }

    /**
     * Supply the unique payment ID and receive corresponding payment details.
     * @summary Retrieve a payment
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPayment(paymentId: string, options?: any) {
        return PaymentsApiFp(this.configuration).getPayment(paymentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all payment refunds
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPaymentRefunds(paymentId: string, options?: any) {
        return PaymentsApiFp(this.configuration).getPaymentRefunds(paymentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all payments
     * @param {ModelInteger} [pageNum] 
     * @param {ModelInteger} [pageSize] 
     * @param {ModelInteger} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public listPayments(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any) {
        return PaymentsApiFp(this.configuration).listPayments(pageNum, pageSize, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Create a full or partial refund back to a customer, from a supplied payment.
     * @summary Refund a payment
     * @param {PaymentRefundRequest} body 
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public refundPayment(body: PaymentRefundRequest, paymentId: string, options?: any) {
        return PaymentsApiFp(this.configuration).refundPayment(body, paymentId, options)(this.fetch, this.basePath);
    }

}
/**
 * RefundsApi - fetch parameter creator
 * @export
 */
export const RefundsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a refund
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefund(refundId: string, options: any = {}): FetchArgs {
            // verify required parameter 'refundId' is not null or undefined
            if (refundId === null || refundId === undefined) {
                throw new RequiredError('refundId','Required parameter refundId was null or undefined when calling getRefund.');
            }
            const localVarPath = `/refunds/{refundId}`
                .replace(`{${"refundId"}}`, encodeURIComponent(String(refundId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all refunds
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options: any = {}): FetchArgs {
            const localVarPath = `/refunds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication merchant-jwt required

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefundsApi - functional programming interface
 * @export
 */
export const RefundsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a refund
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefund(refundId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RefundRecord> {
            const localVarFetchArgs = RefundsApiFetchParamCreator(configuration).getRefund(refundId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all refunds
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RefundRecord>> {
            const localVarFetchArgs = RefundsApiFetchParamCreator(configuration).listRefunds(pageNum, pageSize, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RefundsApi - factory interface
 * @export
 */
export const RefundsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Retrieve a refund
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefund(refundId: string, options?: any) {
            return RefundsApiFp(configuration).getRefund(refundId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all refunds
         * @param {ModelInteger} [pageNum] 
         * @param {ModelInteger} [pageSize] 
         * @param {ModelInteger} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any) {
            return RefundsApiFp(configuration).listRefunds(pageNum, pageSize, limit, options)(fetch, basePath);
        },
    };
};

/**
 * RefundsApi - object-oriented interface
 * @export
 * @class RefundsApi
 * @extends {BaseAPI}
 */
export class RefundsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a refund
     * @param {string} refundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public getRefund(refundId: string, options?: any) {
        return RefundsApiFp(this.configuration).getRefund(refundId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all refunds
     * @param {ModelInteger} [pageNum] 
     * @param {ModelInteger} [pageSize] 
     * @param {ModelInteger} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public listRefunds(pageNum?: ModelInteger, pageSize?: ModelInteger, limit?: ModelInteger, options?: any) {
        return RefundsApiFp(this.configuration).listRefunds(pageNum, pageSize, limit, options)(this.fetch, this.basePath);
    }

}
